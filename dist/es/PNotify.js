/* src/PNotify.svelte generated by Svelte v3.18.2 */
import {
	HtmlTag,
	SvelteComponent,
	action_destroyer,
	append,
	assign,
	attr,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	flush,
	get_spread_object,
	get_spread_update,
	globals,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	outro_and_destroy_block,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text as text_1,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

const { Map: Map_1 } = globals;
import Stack from "./Stack.js";
import { component } from "./Component.js";
import { onMount, beforeUpdate, tick, createEventDispatcher } from "svelte";
import { current_component } from "svelte/internal";
import { forwardEventsBuilder } from "@smui/common/forwardEvents.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[105] = list[i][0];
	child_ctx[106] = list[i][1];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[105] = list[i][0];
	child_ctx[106] = list[i][1];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[105] = list[i][0];
	child_ctx[106] = list[i][1];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[105] = list[i][0];
	child_ctx[106] = list[i][1];
	return child_ctx;
}

// (209:4) {#each modulesPrependContainer as [module, options] (module)}
function create_each_block_3(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[41] }, /*options*/ ctx[106]];
	var switch_value = /*module*/ ctx[105].default;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[1] & /*self, modulesPrependContainer*/ 1088)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[1] & /*self*/ 1024 && { self: /*self*/ ctx[41] },
					dirty[1] & /*modulesPrependContainer*/ 64 && get_spread_object(/*options*/ ctx[106])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[105].default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (212:4) {#if closer && !_nonBlock}
function create_if_block_8(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;
	let div_title_value;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");
			attr(span, "class", span_class_value = /*getIcon*/ ctx[21]("closer"));

			attr(div, "class", div_class_value = "pnotify-closer " + /*getStyle*/ ctx[20]("closer") + " " + (!/*closerHover*/ ctx[16] || /*_interacting*/ ctx[25]
			? ""
			: "pnotify-hidden"));

			attr(div, "role", "button");
			attr(div, "tabindex", "0");
			attr(div, "title", div_title_value = /*labels*/ ctx[19].close);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			dispose = listen(div, "click", /*click_handler*/ ctx[97]);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*closerHover, _interacting*/ 33619968 && div_class_value !== (div_class_value = "pnotify-closer " + /*getStyle*/ ctx[20]("closer") + " " + (!/*closerHover*/ ctx[16] || /*_interacting*/ ctx[25]
			? ""
			: "pnotify-hidden"))) {
				attr(div, "class", div_class_value);
			}

			if (dirty[0] & /*labels*/ 524288 && div_title_value !== (div_title_value = /*labels*/ ctx[19].close)) {
				attr(div, "title", div_title_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			dispose();
		}
	};
}

// (223:4) {#if sticker && !_nonBlock}
function create_if_block_7(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;
	let div_aria_pressed_value;
	let div_title_value;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");

			attr(span, "class", span_class_value = "" + (/*getIcon*/ ctx[21]("sticker") + " " + (/*hide*/ ctx[1]
			? /*getIcon*/ ctx[21]("unstuck")
			: /*getIcon*/ ctx[21]("stuck"))));

			attr(div, "class", div_class_value = "pnotify-sticker " + /*getStyle*/ ctx[20]("sticker") + " " + (!/*stickerHover*/ ctx[18] || /*_interacting*/ ctx[25]
			? ""
			: "pnotify-hidden"));

			attr(div, "role", "button");
			attr(div, "aria-pressed", div_aria_pressed_value = !/*hide*/ ctx[1]);
			attr(div, "tabindex", "0");

			attr(div, "title", div_title_value = /*hide*/ ctx[1]
			? /*labels*/ ctx[19].stick
			: /*labels*/ ctx[19].unstick);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			dispose = listen(div, "click", /*click_handler_1*/ ctx[98]);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*hide*/ 2 && span_class_value !== (span_class_value = "" + (/*getIcon*/ ctx[21]("sticker") + " " + (/*hide*/ ctx[1]
			? /*getIcon*/ ctx[21]("unstuck")
			: /*getIcon*/ ctx[21]("stuck"))))) {
				attr(span, "class", span_class_value);
			}

			if (dirty[0] & /*stickerHover, _interacting*/ 33816576 && div_class_value !== (div_class_value = "pnotify-sticker " + /*getStyle*/ ctx[20]("sticker") + " " + (!/*stickerHover*/ ctx[18] || /*_interacting*/ ctx[25]
			? ""
			: "pnotify-hidden"))) {
				attr(div, "class", div_class_value);
			}

			if (dirty[0] & /*hide*/ 2 && div_aria_pressed_value !== (div_aria_pressed_value = !/*hide*/ ctx[1])) {
				attr(div, "aria-pressed", div_aria_pressed_value);
			}

			if (dirty[0] & /*hide, labels*/ 524290 && div_title_value !== (div_title_value = /*hide*/ ctx[1]
			? /*labels*/ ctx[19].stick
			: /*labels*/ ctx[19].unstick)) {
				attr(div, "title", div_title_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			dispose();
		}
	};
}

// (235:4) {#if icon !== false}
function create_if_block_6(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;

	return {
		c() {
			div = element("div");
			span = element("span");

			attr(span, "class", span_class_value = /*icon*/ ctx[11] === true
			? /*getIcon*/ ctx[21](/*type*/ ctx[2])
			: /*icon*/ ctx[11]);

			attr(div, "class", div_class_value = "pnotify-icon " + /*getStyle*/ ctx[20]("icon"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			/*div_binding*/ ctx[99](div);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon, type*/ 2052 && span_class_value !== (span_class_value = /*icon*/ ctx[11] === true
			? /*getIcon*/ ctx[21](/*type*/ ctx[2])
			: /*icon*/ ctx[11])) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[99](null);
		}
	};
}

// (241:6) {#each modulesPrependContent as [module, options] (module)}
function create_each_block_2(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[41] }, /*options*/ ctx[106]];
	var switch_value = /*module*/ ctx[105].default;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[1] & /*self, modulesPrependContent*/ 1152)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[1] & /*self*/ 1024 && { self: /*self*/ ctx[41] },
					dirty[1] & /*modulesPrependContent*/ 128 && get_spread_object(/*options*/ ctx[106])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[105].default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (244:6) {#if title !== false}
function create_if_block_3(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_titleElement*/ ctx[32] && create_if_block_4(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "pnotify-title " + /*getStyle*/ ctx[20]("title"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_1*/ ctx[100](div);
		},
		p(ctx, dirty) {
			if (!/*_titleElement*/ ctx[32]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_1*/ ctx[100](null);
		}
	};
}

// (246:10) {#if !_titleElement}
function create_if_block_4(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*titleTrusted*/ ctx[4]) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (249:12) {:else}
function create_else_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*title*/ ctx[3]);
			attr(span, "class", "pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 8) set_data(t, /*title*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (247:12) {#if titleTrusted}
function create_if_block_5(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*title*/ ctx[3], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 8) html_tag.p(/*title*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (255:6) {#if text !== false}
function create_if_block(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_textElement*/ ctx[33] && create_if_block_1(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "pnotify-text " + /*getStyle*/ ctx[20]("text"));
			attr(div, "style", /*_maxTextHeightStyle*/ ctx[31]);
			attr(div, "role", "alert");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_2*/ ctx[101](div);
		},
		p(ctx, dirty) {
			if (!/*_textElement*/ ctx[33]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[1] & /*_maxTextHeightStyle*/ 1) {
				attr(div, "style", /*_maxTextHeightStyle*/ ctx[31]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_2*/ ctx[101](null);
		}
	};
}

// (261:10) {#if !_textElement}
function create_if_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*textTrusted*/ ctx[6]) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (264:12) {:else}
function create_else_block(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*text*/ ctx[5]);
			attr(span, "class", "pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 32) set_data(t, /*text*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (262:12) {#if textTrusted}
function create_if_block_2(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*text*/ ctx[5], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 32) html_tag.p(/*text*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (270:6) {#each modulesAppendContent as [module, options] (module)}
function create_each_block_1(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[41] }, /*options*/ ctx[106]];
	var switch_value = /*module*/ ctx[105].default;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[1] & /*self, modulesAppendContent*/ 1280)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[1] & /*self*/ 1024 && { self: /*self*/ ctx[41] },
					dirty[1] & /*modulesAppendContent*/ 256 && get_spread_object(/*options*/ ctx[106])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[105].default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (274:4) {#each modulesAppendContainer as [module, options] (module)}
function create_each_block(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[41] }, /*options*/ ctx[106]];
	var switch_value = /*module*/ ctx[105].default;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[1] & /*self, modulesAppendContainer*/ 1536)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[1] & /*self*/ 1024 && { self: /*self*/ ctx[41] },
					dirty[1] & /*modulesAppendContainer*/ 512 && get_spread_object(/*options*/ ctx[106])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[105].default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div1;
	let each_blocks_3 = [];
	let each0_lookup = new Map_1();
	let t0;
	let t1;
	let t2;
	let t3;
	let div0;
	let each_blocks_2 = [];
	let each1_lookup = new Map_1();
	let t4;
	let t5;
	let t6;
	let each_blocks_1 = [];
	let each2_lookup = new Map_1();
	let div0_class_value;
	let t7;
	let each_blocks = [];
	let each3_lookup = new Map_1();
	let div1_class_value;
	let div1_style_value;
	let div2_class_value;
	let forwardEvents_action;
	let current;
	let dispose;
	let each_value_3 = /*modulesPrependContainer*/ ctx[37];
	const get_key = ctx => /*module*/ ctx[105];

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
	}

	let if_block0 = /*closer*/ ctx[15] && !/*_nonBlock*/ ctx[35] && create_if_block_8(ctx);
	let if_block1 = /*sticker*/ ctx[17] && !/*_nonBlock*/ ctx[35] && create_if_block_7(ctx);
	let if_block2 = /*icon*/ ctx[11] !== false && create_if_block_6(ctx);
	let each_value_2 = /*modulesPrependContent*/ ctx[38];
	const get_key_1 = ctx => /*module*/ ctx[105];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
	}

	let if_block3 = /*title*/ ctx[3] !== false && create_if_block_3(ctx);
	let if_block4 = /*text*/ ctx[5] !== false && create_if_block(ctx);
	let each_value_1 = /*modulesAppendContent*/ ctx[39];
	const get_key_2 = ctx => /*module*/ ctx[105];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = /*modulesAppendContainer*/ ctx[40];
	const get_key_3 = ctx => /*module*/ ctx[105];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_3(child_ctx);
		each3_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t7 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = "pnotify-content " + /*getStyle*/ ctx[20]("content"));
			attr(div1, "class", div1_class_value = "\n      pnotify-container\n      " + /*getStyle*/ ctx[20]("container") + "\n      " + /*getStyle*/ ctx[20](/*type*/ ctx[2]) + "\n      " + (/*shadow*/ ctx[14] ? "pnotify-shadow" : "") + "\n      " + /*_moduleClasses*/ ctx[26].container.join(" ") + "\n    ");
			attr(div1, "style", div1_style_value = "" + (/*_widthStyle*/ ctx[29] + " " + /*_minHeightStyle*/ ctx[30]));
			attr(div1, "role", "alert");
			attr(div2, "data-pnotify", "");

			attr(div2, "class", div2_class_value = "\n    pnotify\n    " + (/*icon*/ ctx[11] !== false ? "pnotify-with-icon" : "") + "\n    " + /*getStyle*/ ctx[20]("elem") + "\n    pnotify-mode-" + /*mode*/ ctx[7] + "\n    " + /*addClass*/ ctx[8] + "\n    " + /*_animatingClass*/ ctx[23] + "\n    " + /*_moveClass*/ ctx[24] + "\n    " + /*_stackDirClass*/ ctx[36] + "\n    " + (/*animation*/ ctx[12] === "fade"
			? "pnotify-fade-" + /*animateSpeed*/ ctx[13]
			: "") + "\n    " + (/*_modal*/ ctx[34]
			? "pnotify-modal " + /*addModalClass*/ ctx[9]
			: /*addModelessClass*/ ctx[10]) + "\n    " + (/*_masking*/ ctx[27] ? "pnotify-masking" : "") + "\n    " + (/*_maskingIn*/ ctx[28] ? "pnotify-masking-in" : "") + "\n    " + /*_moduleClasses*/ ctx[26].elem.join(" ") + "\n  ");

			attr(div2, "aria-live", "assertive");
			attr(div2, "role", "alertdialog");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(div1, null);
			}

			append(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t3);
			append(div1, div0);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div0, null);
			}

			append(div0, t4);
			if (if_block3) if_block3.m(div0, null);
			append(div0, t5);
			if (if_block4) if_block4.m(div0, null);
			append(div0, t6);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			/*div0_binding*/ ctx[102](div0);
			append(div1, t7);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			/*div1_binding*/ ctx[103](div1);
			/*div2_binding*/ ctx[104](div2);
			current = true;

			dispose = [
				action_destroyer(forwardEvents_action = /*forwardEvents*/ ctx[42].call(null, div2)),
				listen(div2, "mouseenter", /*handleInteraction*/ ctx[43]),
				listen(div2, "mouseleave", /*handleLeaveInteraction*/ ctx[44]),
				listen(div2, "focusin", /*handleInteraction*/ ctx[43]),
				listen(div2, "focusout", /*handleLeaveInteraction*/ ctx[44])
			];
		},
		p(ctx, dirty) {
			const each_value_3 = /*modulesPrependContainer*/ ctx[37];
			group_outros();
			each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div1, outro_and_destroy_block, create_each_block_3, t0, get_each_context_3);
			check_outros();

			if (/*closer*/ ctx[15] && !/*_nonBlock*/ ctx[35]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*sticker*/ ctx[17] && !/*_nonBlock*/ ctx[35]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7(ctx);
					if_block1.c();
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*icon*/ ctx[11] !== false) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_6(ctx);
					if_block2.c();
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			const each_value_2 = /*modulesPrependContent*/ ctx[38];
			group_outros();
			each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div0, outro_and_destroy_block, create_each_block_2, t4, get_each_context_2);
			check_outros();

			if (/*title*/ ctx[3] !== false) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_3(ctx);
					if_block3.c();
					if_block3.m(div0, t5);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*text*/ ctx[5] !== false) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block(ctx);
					if_block4.c();
					if_block4.m(div0, t6);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			const each_value_1 = /*modulesAppendContent*/ ctx[39];
			group_outros();
			each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx, each_value_1, each2_lookup, div0, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
			check_outros();
			const each_value = /*modulesAppendContainer*/ ctx[40];
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key_3, 1, ctx, each_value, each3_lookup, div1, outro_and_destroy_block, create_each_block, null, get_each_context);
			check_outros();

			if (!current || dirty[0] & /*type, shadow, _moduleClasses*/ 67125252 && div1_class_value !== (div1_class_value = "\n      pnotify-container\n      " + /*getStyle*/ ctx[20]("container") + "\n      " + /*getStyle*/ ctx[20](/*type*/ ctx[2]) + "\n      " + (/*shadow*/ ctx[14] ? "pnotify-shadow" : "") + "\n      " + /*_moduleClasses*/ ctx[26].container.join(" ") + "\n    ")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*_widthStyle, _minHeightStyle*/ 1610612736 && div1_style_value !== (div1_style_value = "" + (/*_widthStyle*/ ctx[29] + " " + /*_minHeightStyle*/ ctx[30]))) {
				attr(div1, "style", div1_style_value);
			}

			if (!current || dirty[0] & /*icon, mode, addClass, _animatingClass, _moveClass, animation, animateSpeed, addModalClass, addModelessClass, _masking, _maskingIn, _moduleClasses*/ 494944128 | dirty[1] & /*_stackDirClass, _modal*/ 40 && div2_class_value !== (div2_class_value = "\n    pnotify\n    " + (/*icon*/ ctx[11] !== false ? "pnotify-with-icon" : "") + "\n    " + /*getStyle*/ ctx[20]("elem") + "\n    pnotify-mode-" + /*mode*/ ctx[7] + "\n    " + /*addClass*/ ctx[8] + "\n    " + /*_animatingClass*/ ctx[23] + "\n    " + /*_moveClass*/ ctx[24] + "\n    " + /*_stackDirClass*/ ctx[36] + "\n    " + (/*animation*/ ctx[12] === "fade"
			? "pnotify-fade-" + /*animateSpeed*/ ctx[13]
			: "") + "\n    " + (/*_modal*/ ctx[34]
			? "pnotify-modal " + /*addModalClass*/ ctx[9]
			: /*addModelessClass*/ ctx[10]) + "\n    " + (/*_masking*/ ctx[27] ? "pnotify-masking" : "") + "\n    " + (/*_maskingIn*/ ctx[28] ? "pnotify-masking-in" : "") + "\n    " + /*_moduleClasses*/ ctx[26].elem.join(" ") + "\n  ")) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].d();
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d();
			}

			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			/*div0_binding*/ ctx[102](null);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div1_binding*/ ctx[103](null);
			/*div2_binding*/ ctx[104](null);
			run_all(dispose);
		}
	};
}

const alert = options => component(getDefaultArgs(options));
const notice = options => component(getDefaultArgs(options, "notice"));
const info = options => component(getDefaultArgs(options, "info"));
const success = options => component(getDefaultArgs(options, "success"));
const error = options => component(getDefaultArgs(options, "error"));

// Default arguments for the new notice helper functions.
function getDefaultArgs(options, type) {
	if (typeof options !== "object") {
		options = { text: options };
	}

	// Only assign the type if it was requested, so we don't overwrite
	// options.type if it has something assigned.
	if (type) {
		options.type = type;
	}

	let target = document.body;

	if ("stack" in options && options.stack && options.stack.context) {
		target = options.stack.context;
	}

	return { target, props: options };
}

const defaultStack = new Stack({
		dir1: "down",
		dir2: "left",
		firstpos1: 25,
		firstpos2: 25,
		spacing1: 36,
		spacing2: 36,
		push: "bottom"
	});

const defaultModules = new Map();

const defaults = {
	// Type of the notice. 'notice', 'info', 'success', or 'error'.
	type: "notice",
	// The notice's title. Can be a string, an element, or `false` for no title.
	title: false,
	// Whether to trust the title or escape its contents. (Not allow HTML.)
	titleTrusted: false,
	// The notice's text. Can be a string, an element, or `false` for no text.
	text: false,
	// Whether to trust the text or escape its contents. (Not allow HTML.)
	textTrusted: false,
	// What styling classes to use. (Can be 'brighttheme', 'material', or a
	// styling object.) (Note that the Bootstrap modules provide a different
	// default.)
	styling: "brighttheme",
	// What icons classes to use (Can be 'brighttheme', 'material', or an icon
	// object.) (Note that the Font Awesome and Glyphicon modules provide a
	// different default.)
	icons: "brighttheme",
	// Light or dark version of the theme, if supported by the styling. This
	// overrides the CSS media query when a preference is given. (Can be
	// 'no-preference', 'light', or 'dark'.)
	mode: "no-preference",
	// Additional classes to be added to the notice. (For custom styling.)
	addClass: "",
	// Additional classes to be added to the notice, only when in modal.
	addModalClass: "",
	// Additional classes to be added to the notice, only when in modeless.
	addModelessClass: "",
	// Display the notice immediately when it is created.
	autoOpen: true,
	// Width of the notice.
	width: "360px",
	// Minimum height of the notice. It will expand to fit content.
	minHeight: "16px",
	// Maximum height of the text container. If the text goes beyond this
	// height, scrollbars will appear. Use null to remove this restriction.
	maxTextHeight: "200px",
	// Set icon to true to use the default icon for the selected
	// style/type, false for no icon, or a string for your own icon class.
	icon: true,
	// The animation to use when displaying and hiding the notice. 'none'
	// and 'fade' are supported through CSS. Others are supported
	// through the Animate module and Animate.css.
	animation: "fade",
	// Speed at which the notice animates in and out. 'slow', 'normal',
	// or 'fast'. Respectively, 400ms, 250ms, 100ms.
	animateSpeed: "normal",
	// Display a drop shadow.
	shadow: true,
	// After a delay, remove the notice.
	hide: true,
	// Delay in milliseconds before the notice is removed.
	delay: 8000,
	// Reset the hide timer if the mouse moves over the notice.
	mouseReset: true,
	// Provide a button for the user to manually close the notice.
	closer: true,
	// Only show the closer button on hover.
	closerHover: true,
	// Provide a button for the user to manually stick the notice.
	sticker: true,
	// Only show the sticker button on hover.
	stickerHover: true,
	// The various displayed text, helps facilitating internationalization.
	labels: {
		close: "Close",
		stick: "Stick",
		unstick: "Unstick"
	},
	// Remove the notice's elements from the DOM after it is removed.
	remove: true,
	// Whether to remove the notice from the stack (and therefore, stack
	// history) when it is closed.
	destroy: true,
	// The stack on which the notices will be placed. Also controls the
	// direction the notices stack.
	stack: defaultStack,
	// This is where modules and their options should be added. It is a map of
	// `module => options` entries.
	modules: defaultModules
};

let posTimer;

// These actions need to be done once the DOM is ready.
function onDocumentLoaded() {
	if (!defaultStack.context) {
		defaultStack.context = document.body;
	}

	// Reposition the notices when the window resizes.
	window.addEventListener("resize", () => {
		// This timer is used for queueing the position event so it doesn't run
		// repeatedly.
		if (posTimer) {
			clearTimeout(posTimer);
		}

		posTimer = setTimeout(
			() => {
				const event = new Event("pnotify:position");
				document.body.dispatchEvent(event);
				posTimer = null;
			},
			10
		);
	});
}

// Run the deferred actions once the DOM is ready.
if (window && document.body) {
	onDocumentLoaded();
} else {
	document.addEventListener("DOMContentLoaded", onDocumentLoaded);
}

function instance($$self, $$props, $$invalidate) {
	const self = current_component;
	const dispatch = createEventDispatcher();

	const forwardEvents = forwardEventsBuilder(current_component, [
		"pnotify:init",
		"pnotify:mount",
		"pnotify:update",
		"pnotify:beforeOpen",
		"pnotify:afterOpen",
		"pnotify:enterModal",
		"pnotify:leaveModal",
		"pnotify:beforeClose",
		"pnotify:afterClose",
		"pnotify:beforeDestroy",
		"pnotify:afterDestroy",
		"focusin",
		"focusout",
		"animationend",
		"transitionend"
	]);

	let { modules = new Map(defaults.modules) } = $$props;
	let { stack = defaults.stack } = $$props;

	const refs = {
		elem: null,
		container: null,
		content: null,
		iconContainer: null,
		titleContainer: null,
		textContainer: null
	};

	// Run init to give a chance for modules to override defaults.
	const selfDefaults = { ...defaults };

	dispatchLifecycleEvent("init", { notice: self, defaults: selfDefaults });
	let { type = selfDefaults.type } = $$props;
	let { title = selfDefaults.title } = $$props;
	let { titleTrusted = selfDefaults.titleTrusted } = $$props;
	let { text = selfDefaults.text } = $$props;
	let { textTrusted = selfDefaults.textTrusted } = $$props;
	let { styling = selfDefaults.styling } = $$props;
	let { icons = selfDefaults.icons } = $$props;
	let { mode = selfDefaults.mode } = $$props;
	let { addClass = selfDefaults.addClass } = $$props;
	let { addModalClass = selfDefaults.addModalClass } = $$props;
	let { addModelessClass = selfDefaults.addModelessClass } = $$props;
	let { autoOpen = selfDefaults.autoOpen } = $$props;
	let { width = selfDefaults.width } = $$props;
	let { minHeight = selfDefaults.minHeight } = $$props;
	let { maxTextHeight = selfDefaults.maxTextHeight } = $$props;
	let { icon = selfDefaults.icon } = $$props;
	let { animation = selfDefaults.animation } = $$props;
	let { animateSpeed = selfDefaults.animateSpeed } = $$props;
	let { shadow = selfDefaults.shadow } = $$props;
	let { hide = selfDefaults.hide } = $$props;
	let { delay = selfDefaults.delay } = $$props;
	let { mouseReset = selfDefaults.mouseReset } = $$props;
	let { closer = selfDefaults.closer } = $$props;
	let { closerHover = selfDefaults.closerHover } = $$props;
	let { sticker = selfDefaults.sticker } = $$props;
	let { stickerHover = selfDefaults.stickerHover } = $$props;
	let { labels = selfDefaults.labels } = $$props;
	let { remove = selfDefaults.remove } = $$props;
	let { destroy = selfDefaults.destroy } = $$props;

	// The state can be 'waiting', 'opening', 'open', 'closing', or 'closed'.
	let _state = "closed";

	// Auto close timer.
	let _timer = null;

	// Animation timers.
	let _animInTimer = null;

	let _animOutTimer = null;

	// Stores what is currently being animated (in or out).
	let _animating = false;

	// Stores the class that adds entry/exit animation effects.
	let _animatingClass = "";

	// Stores the class that adds movement animation effects.
	let _moveClass = "";

	// Stores whether the notice was hidden by a timer.
	let _timerHide = false;

	// Whether the mouse is over the notice or the notice is focused.
	let _interacting = false;

	// Holds classes that modules add for the notice element or container element.
	let _moduleClasses = { elem: [], container: [] };

	// Modules that change how the notice displays (causing the notice element to
	// not appear) can set these to true to make PNotify handle it correctly.
	let _moduleHandled = false;

	let _moduleOpen = false;

	// The masking control for the second notice in a modalish stack when the
	// first notice is hovered.
	let _masking = false;

	let _maskingIn = false;
	let _maskingTimer = null;

	// Save the old value of hide, so we can reset the timer if it changes.
	let _oldHide = hide;

	const getState = () => _state;

	const getStyle = name => typeof styling === "string"
	? styling + "-" + name
	: name in styling
		? styling[name]
		: styling.prefix + "-" + name;

	const getIcon = name => typeof icons === "string"
	? icons + "-icon-" + name
	: name in icons
		? icons[name]
		: icons.prefix + "-icon-" + name;

	let _oldStack = NaN;
	let _oldModal = false;

	onMount(() => {
		dispatchLifecycleEvent("mount");

		// Display the notice.
		if (autoOpen) {
			open();
		}
	});

	beforeUpdate(async () => {
		dispatchLifecycleEvent("update");

		// Update the timed hiding.
		if (_state !== "closed" && _state !== "waiting" && hide !== _oldHide) {
			if (!hide) {
				cancelClose();
			} else if (!_oldHide) {
				queueClose();
			}
		}

		// Queue a position
		if (_state !== "closed" && _state !== "closing" && stack && !stack._collapsingModalState) {
			stack.queuePosition();
		}

		// Save old options.
		_oldHide = hide;
	});

	function handleInteraction(e) {
		$$invalidate(25, _interacting = true);

		// Stop animation, reset the removal timer when the user interacts.
		if (mouseReset && _state === "closing") {
			if (!_timerHide) {
				return;
			}

			cancelClose();
		}

		// Stop the close timer.
		if (hide && mouseReset) {
			cancelClose();
		}
	}

	function handleLeaveInteraction(e) {
		$$invalidate(25, _interacting = false);

		// Start the close timer.
		if (hide && mouseReset && _animating !== "out") {
			queueClose();
		}
	}

	// This runs an event on all the modules.
	function dispatchLifecycleEvent(event, detail = {}) {
		const eventDetail = { notice: self, ...detail };

		if (event === "init") {
			Array.from(modules).forEach(([module, options]) => "init" in module && module.init(eventDetail));
		}

		let target = refs.elem || stack && stack.context || document.body;

		if (!target) {
			dispatch("pnotify:" + event, eventDetail);
			return true;
		}

		const eventObj = new Event("pnotify:" + event,
		{
				bubbles: event === "init" || event === "mount",
				cancelable: event.startsWith("before")
			});

		eventObj.detail = eventDetail;
		target.dispatchEvent(eventObj);
		return !eventObj.defaultPrevented;
	}

	function insertIntoDOM() {
		// If the notice is not in the DOM, or in the wrong context, append it.
		const target = stack && stack.context || document.body;

		if (!target) {
			throw new Error("No context to insert this notice into.");
		}

		if (!refs.elem) {
			throw new Error("Trying to insert notice before element is available.");
		}

		if (refs.elem.parentNode !== target) {
			target.appendChild(refs.elem);
		}
	}

	function removeFromDOM() {
		refs.elem && refs.elem.parentNode.removeChild(refs.elem);
	}

	let { open = immediate => {
		if (_state === "opening") {
			return;
		}

		if (_state === "open") {
			if (hide) {
				queueClose();
			}

			return;
		}

		if (!_moduleHandled && stack && stack._shouldNoticeWait()) {
			$$invalidate(80, _state = "waiting");
			return;
		}

		if (!dispatchLifecycleEvent("beforeOpen", { immediate })) {
			return;
		}

		$$invalidate(80, _state = "opening");
		$$invalidate(27, _masking = false);

		// This makes the notice visibity: hidden; so its dimensions can be
		// determined.
		$$invalidate(23, _animatingClass = "pnotify-initial pnotify-hidden");

		const afterOpenCallback = () => {
			// Now set it to hide.
			if (hide) {
				queueClose();
			}

			$$invalidate(80, _state = "open");
			dispatchLifecycleEvent("afterOpen", { immediate });
		};

		if (stack) {
			// Notify the stack that a notice has opened.
			stack._handleNoticeOpened(self);
		}

		if (_moduleOpen) {
			afterOpenCallback();
			return;
		}

		insertIntoDOM();

		// Wait until the DOM is updated.
		window.requestAnimationFrame(() => {
			if (_state !== "opening") {
				return;
			}

			if (stack) {
				// Mark the stack so it won't animate the new notice.
				$$invalidate(45, stack._animation = false, stack);

				if (stack.push === "top") {
					// Reset the position data so the notice is positioned as the first
					// notice.
					stack._resetPositionData();
				}

				// Now position the stack's the notices.
				stack._positionNotice(self);

				stack.queuePosition(0);

				// Reset animation.
				$$invalidate(45, stack._animation = true, stack);
			}

			animateIn(afterOpenCallback, immediate);
		});
	} } = $$props;

	let { close = (immediate, timerHide, waitAfterward) => {
		if (_state === "closing" || _state === "closed") {
			return;
		}

		const runDestroy = () => {
			if (!dispatchLifecycleEvent("beforeDestroy")) {
				return;
			}

			if (stack) {
				stack._removeNotice(self);
			}

			self.$destroy();
			dispatchLifecycleEvent("afterDestroy");
		};

		if (_state === "waiting") {
			if (waitAfterward) {
				return;
			}

			$$invalidate(80, _state = "closed");

			// It's debatable whether the notice should be destroyed in this case, but
			// I'm going to go ahead and say yes.
			if (destroy && !waitAfterward) {
				runDestroy();
			}

			return;
		}

		if (!dispatchLifecycleEvent("beforeClose", { immediate, timerHide, waitAfterward })) {
			return;
		}

		$$invalidate(80, _state = "closing");
		_timerHide = !!timerHide; // Make sure it's a boolean.

		if (_timer && _timer !== "prevented" && clearTimeout) {
			clearTimeout(_timer);
		}

		$$invalidate(81, _timer = null);

		animateOut(
			() => {
				$$invalidate(25, _interacting = false);
				_timerHide = false;
				$$invalidate(80, _state = waitAfterward ? "waiting" : "closed");
				dispatchLifecycleEvent("afterClose", { immediate, timerHide, waitAfterward });

				if (stack) {
					stack._handleNoticeClosed(self);
				}

				if (destroy && !waitAfterward) {
					// If we're supposed to destroy the notice, run the destroy module
					// events, remove from stack, and let Svelte handle DOM removal.
					runDestroy();
				} else if (remove && !waitAfterward) {
					// If we're supposed to remove the notice from the DOM, do it.
					removeFromDOM();
				}
			},
			immediate
		);
	} } = $$props;

	let { animateIn = async (callback, immediate) => {
		// Declare that the notice is animating in.
		_animating = "in";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animInTimer) {
				clearTimeout(_animInTimer);
			}

			if (_animating !== "in") {
				return;
			}

			let visible = _moduleOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (visible) {
				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				_animInTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(23, _animatingClass = "pnotify-in");
			await tick();
			$$invalidate(23, _animatingClass = "pnotify-in pnotify-fade-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animInTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(23, _animatingClass = "pnotify-in");
			await tick();
			finished();
		}
	} } = $$props;

	let { animateOut = async (callback, immediate) => {
		// Declare that the notice is animating out.
		_animating = "out";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animOutTimer) {
				clearTimeout(_animOutTimer);
			}

			if (_animating !== "out") {
				return;
			}

			let visible = _moduleOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === "0" || !visible) {
				$$invalidate(23, _animatingClass = "");

				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				// In case this was called before the notice finished animating.
				_animOutTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(23, _animatingClass = "pnotify-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animOutTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(23, _animatingClass = "");
			await tick();
			finished();
		}
	} } = $$props;

	function cancelClose() {
		if (_timer && _timer !== "prevented") {
			clearTimeout(_timer);
		}

		if (_animOutTimer) {
			clearTimeout(_animOutTimer);
		}

		if (_state === "closing") {
			// If it's animating out, stop it.
			$$invalidate(80, _state = "open");

			_animating = false;

			$$invalidate(23, _animatingClass = animation === "fade"
			? "pnotify-in pnotify-fade-in"
			: "pnotify-in");
		}
	}

	function queueClose() {
		if (_timer === "prevented") {
			return;
		}

		// Cancel any current close timer.
		cancelClose();

		$$invalidate(81, _timer = setTimeout(() => close(false, true), isNaN(delay) ? 0 : delay));
	}

	function _preventTimerClose(prevent) {
		if (prevent) {
			cancelClose();
			$$invalidate(81, _timer = "prevented");
		} else if (_timer === "prevented") {
			$$invalidate(81, _timer = null);

			if (_state === "open" && hide) {
				queueClose();
			}
		}
	}

	function on(...args) {
		return self.$on(...args);
	}

	function update(...args) {
		return self.$set(...args);
	}

	function fire(name, detail) {
		dispatch(name, detail);
	}

	function addModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				_moduleClasses[element].push(className);
			}
		}

		$$invalidate(26, _moduleClasses);
	}

	function removeModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];
			const idx = _moduleClasses[element].indexOf(className);

			if (idx !== -1) {
				_moduleClasses[element].splice(idx, 1);
			}
		}

		$$invalidate(26, _moduleClasses);
	}

	function hasModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				return false;
			}
		}

		return true;
	}

	function getModuleHandled() {
		return _moduleHandled;
	}

	function setModuleHandled(value) {
		return _moduleHandled = value;
	}

	function getModuleOpen() {
		return _moduleOpen;
	}

	function setModuleOpen(value) {
		return _moduleOpen = value;
	}

	function setAnimating(value) {
		return _animating = value;
	}

	function getAnimatingClass() {
		return _animatingClass;
	}

	function setAnimatingClass(value) {
		return $$invalidate(23, _animatingClass = value);
	}

	function _getMoveClass() {
		return _moveClass;
	}

	function _setMoveClass(value) {
		return $$invalidate(24, _moveClass = value);
	}

	async function _setMasking(value, immediate, callback) {
		if (_maskingTimer) {
			clearTimeout(_maskingTimer);
		}

		if (_masking === value) {
			return;
		}

		if (value) {
			$$invalidate(27, _masking = true);
			$$invalidate(28, _maskingIn = !!immediate);
			insertIntoDOM();
			await tick();

			window.requestAnimationFrame(() => {
				if (_masking) {
					if (immediate && callback) {
						callback();
					} else {
						$$invalidate(28, _maskingIn = true);

						const finished = () => {
							refs.elem && refs.elem.removeEventListener("transitionend", finished);

							if (_maskingTimer) {
								clearTimeout(_maskingTimer);
							}

							if (_maskingIn && callback) {
								callback();
							}
						};

						refs.elem && refs.elem.addEventListener("transitionend", finished);
						_maskingTimer = setTimeout(finished, 650);
					}
				}
			});
		} else if (immediate) {
			$$invalidate(27, _masking = false);
			$$invalidate(28, _maskingIn = false);

			if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
				removeFromDOM();
			}

			if (callback) {
				callback();
			}
		} else {
			const finished = () => {
				refs.elem && refs.elem.removeEventListener("transitionend", finished);

				if (_maskingTimer) {
					clearTimeout(_maskingTimer);
				}

				if (!_maskingIn) {
					$$invalidate(27, _masking = false);

					if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
						removeFromDOM();
					}

					if (callback) {
						callback();
					}
				}
			};

			$$invalidate(28, _maskingIn = false);
			refs.elem && refs.elem.addEventListener("transitionend", finished);

			// eslint-disable-next-line no-unused-expressions
			refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.

			// Just in case the event doesn't fire, call it after 650 ms.
			_maskingTimer = setTimeout(finished, 650);
		}
	}

	const click_handler = () => close(false);
	const click_handler_1 = () => $$invalidate(1, hide = !hide);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.iconContainer = $$value;
			$$invalidate(0, refs);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.titleContainer = $$value;
			$$invalidate(0, refs);
		});
	}

	function div_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.textContainer = $$value;
			$$invalidate(0, refs);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.content = $$value;
			$$invalidate(0, refs);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.container = $$value;
			$$invalidate(0, refs);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.elem = $$value;
			$$invalidate(0, refs);
		});
	}

	$$self.$set = $$props => {
		if ("modules" in $$props) $$invalidate(46, modules = $$props.modules);
		if ("stack" in $$props) $$invalidate(45, stack = $$props.stack);
		if ("type" in $$props) $$invalidate(2, type = $$props.type);
		if ("title" in $$props) $$invalidate(3, title = $$props.title);
		if ("titleTrusted" in $$props) $$invalidate(4, titleTrusted = $$props.titleTrusted);
		if ("text" in $$props) $$invalidate(5, text = $$props.text);
		if ("textTrusted" in $$props) $$invalidate(6, textTrusted = $$props.textTrusted);
		if ("styling" in $$props) $$invalidate(47, styling = $$props.styling);
		if ("icons" in $$props) $$invalidate(48, icons = $$props.icons);
		if ("mode" in $$props) $$invalidate(7, mode = $$props.mode);
		if ("addClass" in $$props) $$invalidate(8, addClass = $$props.addClass);
		if ("addModalClass" in $$props) $$invalidate(9, addModalClass = $$props.addModalClass);
		if ("addModelessClass" in $$props) $$invalidate(10, addModelessClass = $$props.addModelessClass);
		if ("autoOpen" in $$props) $$invalidate(49, autoOpen = $$props.autoOpen);
		if ("width" in $$props) $$invalidate(50, width = $$props.width);
		if ("minHeight" in $$props) $$invalidate(51, minHeight = $$props.minHeight);
		if ("maxTextHeight" in $$props) $$invalidate(52, maxTextHeight = $$props.maxTextHeight);
		if ("icon" in $$props) $$invalidate(11, icon = $$props.icon);
		if ("animation" in $$props) $$invalidate(12, animation = $$props.animation);
		if ("animateSpeed" in $$props) $$invalidate(13, animateSpeed = $$props.animateSpeed);
		if ("shadow" in $$props) $$invalidate(14, shadow = $$props.shadow);
		if ("hide" in $$props) $$invalidate(1, hide = $$props.hide);
		if ("delay" in $$props) $$invalidate(53, delay = $$props.delay);
		if ("mouseReset" in $$props) $$invalidate(54, mouseReset = $$props.mouseReset);
		if ("closer" in $$props) $$invalidate(15, closer = $$props.closer);
		if ("closerHover" in $$props) $$invalidate(16, closerHover = $$props.closerHover);
		if ("sticker" in $$props) $$invalidate(17, sticker = $$props.sticker);
		if ("stickerHover" in $$props) $$invalidate(18, stickerHover = $$props.stickerHover);
		if ("labels" in $$props) $$invalidate(19, labels = $$props.labels);
		if ("remove" in $$props) $$invalidate(55, remove = $$props.remove);
		if ("destroy" in $$props) $$invalidate(56, destroy = $$props.destroy);
		if ("open" in $$props) $$invalidate(58, open = $$props.open);
		if ("close" in $$props) $$invalidate(22, close = $$props.close);
		if ("animateIn" in $$props) $$invalidate(59, animateIn = $$props.animateIn);
		if ("animateOut" in $$props) $$invalidate(60, animateOut = $$props.animateOut);
	};

	let _widthStyle;
	let _minHeightStyle;
	let _maxTextHeightStyle;
	let _titleElement;
	let _textElement;
	let _modal;
	let _nonBlock;
	let _stackDirClass;
	let modulesPrependContainer;
	let modulesPrependContent;
	let modulesAppendContent;
	let modulesAppendContainer;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*width*/ 524288) {
			// Grab the icons from the icons object or use provided icons
			$: $$invalidate(29, _widthStyle = typeof width === "string" ? "width: " + width + ";" : "");
		}

		if ($$self.$$.dirty[1] & /*minHeight*/ 1048576) {
			$: $$invalidate(30, _minHeightStyle = typeof minHeight === "string"
			? "min-height: " + minHeight + ";"
			: "");
		}

		if ($$self.$$.dirty[1] & /*maxTextHeight*/ 2097152) {
			$: $$invalidate(31, _maxTextHeightStyle = typeof maxTextHeight === "string"
			? "max-height: " + maxTextHeight + "; overflow-y: auto; overscroll-behavior: contain;"
			: "");
		}

		if ($$self.$$.dirty[0] & /*title*/ 8) {
			$: $$invalidate(32, _titleElement = title instanceof HTMLElement);
		}

		if ($$self.$$.dirty[0] & /*text*/ 32) {
			$: $$invalidate(33, _textElement = text instanceof HTMLElement);
		}

		if ($$self.$$.dirty[1] & /*stack*/ 16384 | $$self.$$.dirty[2] & /*_timer, _state*/ 786432) {
			// Whether the notification is open in a modal stack (or a modalish stack in
			// modal state).
			$: $$invalidate(34, _modal = stack && (stack.modal === true || stack.modal === "ish" && _timer === "prevented") && ["open", "opening", "closing"].indexOf(_state) !== -1);
		}

		if ($$self.$$.dirty[0] & /*addClass, addModalClass, addModelessClass*/ 1792 | $$self.$$.dirty[1] & /*_modal*/ 8) {
			$: $$invalidate(35, _nonBlock = addClass.match(/\bnonblock\b/) || addModalClass.match(/\bnonblock\b/) && _modal || addModelessClass.match(/\bnonblock\b/) && !_modal);
		}

		if ($$self.$$.dirty[1] & /*stack*/ 16384) {
			// This is for specific styling for how notices stack.
			$: $$invalidate(36, _stackDirClass = stack && stack.dir1 ? "pnotify-stack-" + stack.dir1 : "");
		}

		if ($$self.$$.dirty[1] & /*modules*/ 32768) {
			// Filter through the module objects, getting an array for each position.
			$: $$invalidate(37, modulesPrependContainer = Array.from(modules).filter(([module, options]) => module.position === "PrependContainer"));
		}

		if ($$self.$$.dirty[1] & /*modules*/ 32768) {
			$: $$invalidate(38, modulesPrependContent = Array.from(modules).filter(([module, options]) => module.position === "PrependContent"));
		}

		if ($$self.$$.dirty[1] & /*modules*/ 32768) {
			$: $$invalidate(39, modulesAppendContent = Array.from(modules).filter(([module, options]) => module.position === "AppendContent"));
		}

		if ($$self.$$.dirty[1] & /*modules*/ 32768) {
			$: $$invalidate(40, modulesAppendContainer = Array.from(modules).filter(([module, options]) => module.position === "AppendContainer"));
		}

		if ($$self.$$.dirty[0] & /*refs, title*/ 9 | $$self.$$.dirty[1] & /*_titleElement*/ 2) {
			$: if (_titleElement && refs.titleContainer) {
				refs.titleContainer.appendChild(title);
			}
		}

		if ($$self.$$.dirty[0] & /*refs, text*/ 33 | $$self.$$.dirty[1] & /*_textElement*/ 4) {
			$: if (_textElement && refs.textContainer) {
				refs.textContainer.appendChild(text);
			}
		}

		if ($$self.$$.dirty[1] & /*stack*/ 16384 | $$self.$$.dirty[2] & /*_oldStack*/ 268435456) {
			$: if (_oldStack !== stack) {
				if (_oldStack) {
					// Remove the notice from the old stack.
					_oldStack._removeNotice(self);
				}

				if (stack) {
					// Add the notice to the stack.
					stack._addNotice(self);
				}

				$$invalidate(90, _oldStack = stack);
			}
		}

		if ($$self.$$.dirty[1] & /*_modal*/ 8 | $$self.$$.dirty[2] & /*_oldModal*/ 536870912) {
			$: if (_oldModal !== _modal) {
				dispatchLifecycleEvent(_modal ? "enterModal" : "leaveModal");
				$$invalidate(91, _oldModal = _modal);
			}
		}
	};

	return [
		refs,
		hide,
		type,
		title,
		titleTrusted,
		text,
		textTrusted,
		mode,
		addClass,
		addModalClass,
		addModelessClass,
		icon,
		animation,
		animateSpeed,
		shadow,
		closer,
		closerHover,
		sticker,
		stickerHover,
		labels,
		getStyle,
		getIcon,
		close,
		_animatingClass,
		_moveClass,
		_interacting,
		_moduleClasses,
		_masking,
		_maskingIn,
		_widthStyle,
		_minHeightStyle,
		_maxTextHeightStyle,
		_titleElement,
		_textElement,
		_modal,
		_nonBlock,
		_stackDirClass,
		modulesPrependContainer,
		modulesPrependContent,
		modulesAppendContent,
		modulesAppendContainer,
		self,
		forwardEvents,
		handleInteraction,
		handleLeaveInteraction,
		stack,
		modules,
		styling,
		icons,
		autoOpen,
		width,
		minHeight,
		maxTextHeight,
		delay,
		mouseReset,
		remove,
		destroy,
		getState,
		open,
		animateIn,
		animateOut,
		cancelClose,
		queueClose,
		_preventTimerClose,
		on,
		update,
		fire,
		addModuleClass,
		removeModuleClass,
		hasModuleClass,
		getModuleHandled,
		setModuleHandled,
		getModuleOpen,
		setModuleOpen,
		setAnimating,
		getAnimatingClass,
		setAnimatingClass,
		_getMoveClass,
		_setMoveClass,
		_setMasking,
		_state,
		_timer,
		_animInTimer,
		_animOutTimer,
		_animating,
		_timerHide,
		_moduleHandled,
		_moduleOpen,
		_maskingTimer,
		_oldHide,
		_oldStack,
		_oldModal,
		dispatch,
		selfDefaults,
		dispatchLifecycleEvent,
		insertIntoDOM,
		removeFromDOM,
		click_handler,
		click_handler_1,
		div_binding,
		div_binding_1,
		div_binding_2,
		div0_binding,
		div1_binding,
		div2_binding
	];
}

class PNotify extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				modules: 46,
				stack: 45,
				refs: 0,
				type: 2,
				title: 3,
				titleTrusted: 4,
				text: 5,
				textTrusted: 6,
				styling: 47,
				icons: 48,
				mode: 7,
				addClass: 8,
				addModalClass: 9,
				addModelessClass: 10,
				autoOpen: 49,
				width: 50,
				minHeight: 51,
				maxTextHeight: 52,
				icon: 11,
				animation: 12,
				animateSpeed: 13,
				shadow: 14,
				hide: 1,
				delay: 53,
				mouseReset: 54,
				closer: 15,
				closerHover: 16,
				sticker: 17,
				stickerHover: 18,
				labels: 19,
				remove: 55,
				destroy: 56,
				getState: 57,
				getStyle: 20,
				getIcon: 21,
				open: 58,
				close: 22,
				animateIn: 59,
				animateOut: 60,
				cancelClose: 61,
				queueClose: 62,
				_preventTimerClose: 63,
				on: 64,
				update: 65,
				fire: 66,
				addModuleClass: 67,
				removeModuleClass: 68,
				hasModuleClass: 69,
				getModuleHandled: 70,
				setModuleHandled: 71,
				getModuleOpen: 72,
				setModuleOpen: 73,
				setAnimating: 74,
				getAnimatingClass: 75,
				setAnimatingClass: 76,
				_getMoveClass: 77,
				_setMoveClass: 78,
				_setMasking: 79
			},
			[-1, -1, -1, -1]
		);
	}

	get modules() {
		return this.$$.ctx[46];
	}

	set modules(modules) {
		this.$set({ modules });
		flush();
	}

	get stack() {
		return this.$$.ctx[45];
	}

	set stack(stack) {
		this.$set({ stack });
		flush();
	}

	get refs() {
		return this.$$.ctx[0];
	}

	get type() {
		return this.$$.ctx[2];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get title() {
		return this.$$.ctx[3];
	}

	set title(title) {
		this.$set({ title });
		flush();
	}

	get titleTrusted() {
		return this.$$.ctx[4];
	}

	set titleTrusted(titleTrusted) {
		this.$set({ titleTrusted });
		flush();
	}

	get text() {
		return this.$$.ctx[5];
	}

	set text(text) {
		this.$set({ text });
		flush();
	}

	get textTrusted() {
		return this.$$.ctx[6];
	}

	set textTrusted(textTrusted) {
		this.$set({ textTrusted });
		flush();
	}

	get styling() {
		return this.$$.ctx[47];
	}

	set styling(styling) {
		this.$set({ styling });
		flush();
	}

	get icons() {
		return this.$$.ctx[48];
	}

	set icons(icons) {
		this.$set({ icons });
		flush();
	}

	get mode() {
		return this.$$.ctx[7];
	}

	set mode(mode) {
		this.$set({ mode });
		flush();
	}

	get addClass() {
		return this.$$.ctx[8];
	}

	set addClass(addClass) {
		this.$set({ addClass });
		flush();
	}

	get addModalClass() {
		return this.$$.ctx[9];
	}

	set addModalClass(addModalClass) {
		this.$set({ addModalClass });
		flush();
	}

	get addModelessClass() {
		return this.$$.ctx[10];
	}

	set addModelessClass(addModelessClass) {
		this.$set({ addModelessClass });
		flush();
	}

	get autoOpen() {
		return this.$$.ctx[49];
	}

	set autoOpen(autoOpen) {
		this.$set({ autoOpen });
		flush();
	}

	get width() {
		return this.$$.ctx[50];
	}

	set width(width) {
		this.$set({ width });
		flush();
	}

	get minHeight() {
		return this.$$.ctx[51];
	}

	set minHeight(minHeight) {
		this.$set({ minHeight });
		flush();
	}

	get maxTextHeight() {
		return this.$$.ctx[52];
	}

	set maxTextHeight(maxTextHeight) {
		this.$set({ maxTextHeight });
		flush();
	}

	get icon() {
		return this.$$.ctx[11];
	}

	set icon(icon) {
		this.$set({ icon });
		flush();
	}

	get animation() {
		return this.$$.ctx[12];
	}

	set animation(animation) {
		this.$set({ animation });
		flush();
	}

	get animateSpeed() {
		return this.$$.ctx[13];
	}

	set animateSpeed(animateSpeed) {
		this.$set({ animateSpeed });
		flush();
	}

	get shadow() {
		return this.$$.ctx[14];
	}

	set shadow(shadow) {
		this.$set({ shadow });
		flush();
	}

	get hide() {
		return this.$$.ctx[1];
	}

	set hide(hide) {
		this.$set({ hide });
		flush();
	}

	get delay() {
		return this.$$.ctx[53];
	}

	set delay(delay) {
		this.$set({ delay });
		flush();
	}

	get mouseReset() {
		return this.$$.ctx[54];
	}

	set mouseReset(mouseReset) {
		this.$set({ mouseReset });
		flush();
	}

	get closer() {
		return this.$$.ctx[15];
	}

	set closer(closer) {
		this.$set({ closer });
		flush();
	}

	get closerHover() {
		return this.$$.ctx[16];
	}

	set closerHover(closerHover) {
		this.$set({ closerHover });
		flush();
	}

	get sticker() {
		return this.$$.ctx[17];
	}

	set sticker(sticker) {
		this.$set({ sticker });
		flush();
	}

	get stickerHover() {
		return this.$$.ctx[18];
	}

	set stickerHover(stickerHover) {
		this.$set({ stickerHover });
		flush();
	}

	get labels() {
		return this.$$.ctx[19];
	}

	set labels(labels) {
		this.$set({ labels });
		flush();
	}

	get remove() {
		return this.$$.ctx[55];
	}

	set remove(remove) {
		this.$set({ remove });
		flush();
	}

	get destroy() {
		return this.$$.ctx[56];
	}

	set destroy(destroy) {
		this.$set({ destroy });
		flush();
	}

	get getState() {
		return this.$$.ctx[57];
	}

	get getStyle() {
		return this.$$.ctx[20];
	}

	get getIcon() {
		return this.$$.ctx[21];
	}

	get open() {
		return this.$$.ctx[58];
	}

	set open(open) {
		this.$set({ open });
		flush();
	}

	get close() {
		return this.$$.ctx[22];
	}

	set close(close) {
		this.$set({ close });
		flush();
	}

	get animateIn() {
		return this.$$.ctx[59];
	}

	set animateIn(animateIn) {
		this.$set({ animateIn });
		flush();
	}

	get animateOut() {
		return this.$$.ctx[60];
	}

	set animateOut(animateOut) {
		this.$set({ animateOut });
		flush();
	}

	get cancelClose() {
		return this.$$.ctx[61];
	}

	get queueClose() {
		return this.$$.ctx[62];
	}

	get _preventTimerClose() {
		return this.$$.ctx[63];
	}

	get on() {
		return this.$$.ctx[64];
	}

	get update() {
		return this.$$.ctx[65];
	}

	get fire() {
		return this.$$.ctx[66];
	}

	get addModuleClass() {
		return this.$$.ctx[67];
	}

	get removeModuleClass() {
		return this.$$.ctx[68];
	}

	get hasModuleClass() {
		return this.$$.ctx[69];
	}

	get getModuleHandled() {
		return this.$$.ctx[70];
	}

	get setModuleHandled() {
		return this.$$.ctx[71];
	}

	get getModuleOpen() {
		return this.$$.ctx[72];
	}

	get setModuleOpen() {
		return this.$$.ctx[73];
	}

	get setAnimating() {
		return this.$$.ctx[74];
	}

	get getAnimatingClass() {
		return this.$$.ctx[75];
	}

	get setAnimatingClass() {
		return this.$$.ctx[76];
	}

	get _getMoveClass() {
		return this.$$.ctx[77];
	}

	get _setMoveClass() {
		return this.$$.ctx[78];
	}

	get _setMasking() {
		return this.$$.ctx[79];
	}
}

export default PNotify;

export {
	Stack,
	alert,
	notice,
	info,
	success,
	error,
	defaultStack,
	defaultModules,
	defaults
};
//# sourceMappingURL=PNotify.js.map