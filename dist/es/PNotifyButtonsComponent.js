/* src/PNotifyButtonsComponent.html generated by Svelte v3.18.2 */
import {
	SvelteComponent,
	append,
	attr,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	safe_not_equal,
	space
} from "svelte/internal";

import { icons } from "./PNotifyCore";
import { onDestroy, beforeUpdate, tick } from "svelte";

function create_if_block_1(ctx) {
	let div;
	let span;
	let div_class_value;
	let div_title_value;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");
			attr(span, "class", /*closerClass*/ ctx[10]);

			attr(div, "class", div_class_value = "ui-pnotify-closer " + /*self*/ ctx[0].getStyle("closer") + " " + (!/*closerHover*/ ctx[3] || /*mouseIsIn*/ ctx[6]
			? ""
			: "ui-pnotify-buttons-hidden"));

			attr(div, "role", "button");
			attr(div, "tabindex", "0");
			attr(div, "title", div_title_value = /*labels*/ ctx[5].close);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			dispose = listen(div, "click", /*handleCloserClick*/ ctx[12]);
		},
		p(ctx, dirty) {
			if (dirty & /*closerClass*/ 1024) {
				attr(span, "class", /*closerClass*/ ctx[10]);
			}

			if (dirty & /*self, closerHover, mouseIsIn*/ 73 && div_class_value !== (div_class_value = "ui-pnotify-closer " + /*self*/ ctx[0].getStyle("closer") + " " + (!/*closerHover*/ ctx[3] || /*mouseIsIn*/ ctx[6]
			? ""
			: "ui-pnotify-buttons-hidden"))) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*labels*/ 32 && div_title_value !== (div_title_value = /*labels*/ ctx[5].close)) {
				attr(div, "title", div_title_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			dispose();
		}
	};
}

// (61:0) {#if sticker && !(self.refs.elem && self.refs.elem.classList.contains('nonblock'))}
function create_if_block(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;
	let div_aria_pressed_value;
	let div_title_value;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");

			attr(span, "class", span_class_value = "" + (/*stickerClass*/ ctx[7] + " " + (/*self*/ ctx[0].hide
			? /*unstuckClass*/ ctx[9]
			: /*stuckClass*/ ctx[8])));

			attr(div, "class", div_class_value = "ui-pnotify-sticker " + /*self*/ ctx[0].getStyle("sticker") + " " + (!/*stickerHover*/ ctx[4] || /*mouseIsIn*/ ctx[6]
			? ""
			: "ui-pnotify-buttons-hidden"));

			attr(div, "role", "button");
			attr(div, "aria-pressed", div_aria_pressed_value = !/*self*/ ctx[0].hide);
			attr(div, "tabindex", "0");

			attr(div, "title", div_title_value = /*self*/ ctx[0].hide
			? /*labels*/ ctx[5].stick
			: /*labels*/ ctx[5].unstick);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			dispose = listen(div, "click", /*handleStickerClick*/ ctx[11]);
		},
		p(ctx, dirty) {
			if (dirty & /*stickerClass, self, unstuckClass, stuckClass*/ 897 && span_class_value !== (span_class_value = "" + (/*stickerClass*/ ctx[7] + " " + (/*self*/ ctx[0].hide
			? /*unstuckClass*/ ctx[9]
			: /*stuckClass*/ ctx[8])))) {
				attr(span, "class", span_class_value);
			}

			if (dirty & /*self, stickerHover, mouseIsIn*/ 81 && div_class_value !== (div_class_value = "ui-pnotify-sticker " + /*self*/ ctx[0].getStyle("sticker") + " " + (!/*stickerHover*/ ctx[4] || /*mouseIsIn*/ ctx[6]
			? ""
			: "ui-pnotify-buttons-hidden"))) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*self*/ 1 && div_aria_pressed_value !== (div_aria_pressed_value = !/*self*/ ctx[0].hide)) {
				attr(div, "aria-pressed", div_aria_pressed_value);
			}

			if (dirty & /*self, labels*/ 33 && div_title_value !== (div_title_value = /*self*/ ctx[0].hide
			? /*labels*/ ctx[5].stick
			: /*labels*/ ctx[5].unstick)) {
				attr(div, "title", div_title_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let show_if_1 = /*closer*/ ctx[2] && !(/*self*/ ctx[0].refs.elem && /*self*/ ctx[0].refs.elem.classList.contains("nonblock"));
	let t;
	let show_if = /*sticker*/ ctx[1] && !(/*self*/ ctx[0].refs.elem && /*self*/ ctx[0].refs.elem.classList.contains("nonblock"));
	let if_block1_anchor;
	let if_block0 = show_if_1 && create_if_block_1(ctx);
	let if_block1 = show_if && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*closer, self*/ 5) show_if_1 = /*closer*/ ctx[2] && !(/*self*/ ctx[0].refs.elem && /*self*/ ctx[0].refs.elem.classList.contains("nonblock"));

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*sticker, self*/ 3) show_if = /*sticker*/ ctx[1] && !(/*self*/ ctx[0].refs.elem && /*self*/ ctx[0].refs.elem.classList.contains("nonblock"));

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

const key = "Buttons";

const defaults = {
	// Provide a button for the user to manually close the notice.
	closer: true,
	// Only show the closer button on hover.
	closerHover: true,
	// Provide a button for the user to manually stick the notice.
	sticker: true,
	// Only show the sticker button on hover.
	stickerHover: true,
	// The various displayed text, helps facilitating internationalization.
	labels: {
		close: "Close",
		stick: "Stick",
		unstick: "Unstick"
	},
	// The classes to use for button icons. Leave them null to use the classes from the styling you're using.
	classes: {
		closer: null,
		sticker: null,
		stuck: null,
		unstuck: null
	}
};

// Add button icons to icons objects.
Object.assign(icons.bootstrap3, {
	closer: "glyphicon glyphicon-remove",
	sticker: "glyphicon",
	stuck: "glyphicon-play",
	unstuck: "glyphicon-pause"
});

Object.assign(icons.fontawesome4, {
	closer: "fa fa-times",
	sticker: "fa",
	stuck: "fa-play",
	unstuck: "fa-pause"
});

Object.assign(icons.fontawesome5, {
	closer: "fas fa-times",
	sticker: "fas",
	stuck: "fa-play",
	unstuck: "fa-pause"
});

function instance($$self, $$props, $$invalidate) {
	let { self = null } = $$props;
	let { closer = defaults.closer } = $$props;
	let { closerHover = defaults.closerHover } = $$props;
	let { sticker = defaults.sticker } = $$props;
	let { stickerHover = defaults.stickerHover } = $$props;
	let { labels = defaults.labels } = $$props;
	let { classes = defaults.classes } = $$props;
	let mouseIsIn = false;

	// This keeps the beforeUpdate handler from going into a loop when we're taming Font Awesome's magic.
	let updatingIcon = false;

	// Save the old value of hide and icon, so we can do our magic.
	let oldIcon;

	beforeUpdate(async () => {
		if (updatingIcon) {
			return;
		}

		// Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
		// In order to make it play nice with Svelte, we have to clear the element
		// and make it again.
		const icon = self.hide ? unstuckClass : stuckClass;

		if (icon !== oldIcon && (self.icons === "fontawesome5" || typeof stickerClass === "string" && stickerClass.match(/(^| )fa[srlb]($| )/) || typeof icon === "string" && icon.match(/(^| )fa[srlb]($| )/))) {
			$$invalidate(1, sticker = false);
			updatingIcon = true;
			await tick();
			$$invalidate(1, sticker = true);
			updatingIcon = false;
			oldIcon = icon;
		}
	});

	let removeMouseEnterHandler = self.on("mouseenter", handleMouseEnter);
	let removeMouseLeaveHandler = self.on("mouseleave", handleMouseLeave);

	onDestroy(() => {
		removeMouseEnterHandler && removeMouseEnterHandler();
		removeMouseLeaveHandler && removeMouseLeaveHandler();
	});

	function handleMouseEnter() {
		$$invalidate(6, mouseIsIn = true);
	}

	function handleMouseLeave() {
		$$invalidate(6, mouseIsIn = false);
	}

	function handleStickerClick() {
		$$invalidate(0, self.hide = !self.hide, self);
	}

	function handleCloserClick() {
		self.close(false);
		$$invalidate(6, mouseIsIn = false);
	}

	$$self.$set = $$props => {
		if ("self" in $$props) $$invalidate(0, self = $$props.self);
		if ("closer" in $$props) $$invalidate(2, closer = $$props.closer);
		if ("closerHover" in $$props) $$invalidate(3, closerHover = $$props.closerHover);
		if ("sticker" in $$props) $$invalidate(1, sticker = $$props.sticker);
		if ("stickerHover" in $$props) $$invalidate(4, stickerHover = $$props.stickerHover);
		if ("labels" in $$props) $$invalidate(5, labels = $$props.labels);
		if ("classes" in $$props) $$invalidate(13, classes = $$props.classes);
	};

	let stickerClass;
	let stuckClass;
	let unstuckClass;
	let closerClass;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*self, classes*/ 8193) {
			// These are button icon classes.
			$: $$invalidate(7, stickerClass = self
			? classes.sticker === null
				? self.getIcon("sticker")
				: classes.sticker
			: "");
		}

		if ($$self.$$.dirty & /*self, classes*/ 8193) {
			$: $$invalidate(8, stuckClass = self
			? classes.stuck === null
				? self.getIcon("stuck")
				: classes.stuck
			: "");
		}

		if ($$self.$$.dirty & /*self, classes*/ 8193) {
			$: $$invalidate(9, unstuckClass = self
			? classes.unstuck === null
				? self.getIcon("unstuck")
				: classes.unstuck
			: "");
		}

		if ($$self.$$.dirty & /*self, classes*/ 8193) {
			$: $$invalidate(10, closerClass = self
			? classes.closer === null
				? self.getIcon("closer")
				: classes.closer
			: "");
		}
	};

	return [
		self,
		sticker,
		closer,
		closerHover,
		stickerHover,
		labels,
		mouseIsIn,
		stickerClass,
		stuckClass,
		unstuckClass,
		closerClass,
		handleStickerClick,
		handleCloserClick,
		classes
	];
}

class PNotifyButtonsComponent extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			self: 0,
			closer: 2,
			closerHover: 3,
			sticker: 1,
			stickerHover: 4,
			labels: 5,
			classes: 13
		});
	}
}

export default PNotifyButtonsComponent;
export { key, defaults };
//# sourceMappingURL=PNotifyButtonsComponent.js.map