/* src/PNotifyConfirm.svelte generated by Svelte v3.18.2 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	set_style,
	space,
	text
} from "svelte/internal";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	return child_ctx;
}

// (45:0) {#if confirm || prompt}
function create_if_block(ctx) {
	let div1;
	let t;
	let div0;
	let div0_class_value;
	let div1_class_value;
	let if_block = /*prompt*/ ctx[3] && create_if_block_2(ctx);
	let each_value = /*buttons*/ ctx[7];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = "\n        pnotify-action-bar\n        " + /*self*/ ctx[1].getStyle("action-bar") + "\n      ");
			set_style(div0, "justify-content", /*align*/ ctx[6]);
			attr(div1, "class", div1_class_value = "\n      pnotify-confirm\n      " + /*self*/ ctx[1].getStyle("text") + "\n      " + /*self*/ ctx[1].getStyle("confirm") + "\n    ");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			/*div0_binding*/ ctx[20](div0);
		},
		p(ctx, dirty) {
			if (/*prompt*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(div1, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*self, buttons, handleClick*/ 2178) {
				each_value = /*buttons*/ ctx[7];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*self*/ 2 && div0_class_value !== (div0_class_value = "\n        pnotify-action-bar\n        " + /*self*/ ctx[1].getStyle("action-bar") + "\n      ")) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty & /*align*/ 64) {
				set_style(div0, "justify-content", /*align*/ ctx[6]);
			}

			if (dirty & /*self*/ 2 && div1_class_value !== (div1_class_value = "\n      pnotify-confirm\n      " + /*self*/ ctx[1].getStyle("text") + "\n      " + /*self*/ ctx[1].getStyle("confirm") + "\n    ")) {
				attr(div1, "class", div1_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			/*div0_binding*/ ctx[20](null);
		}
	};
}

// (53:4) {#if prompt}
function create_if_block_2(ctx) {
	let div;
	let div_class_value;

	function select_block_type(ctx, dirty) {
		if (/*promptMultiLine*/ ctx[5]) return create_if_block_3;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", div_class_value = "\n          pnotify-prompt-bar\n          " + /*self*/ ctx[1].getStyle("prompt-bar") + "\n        ");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_block.m(div, null);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*self*/ 2 && div_class_value !== (div_class_value = "\n          pnotify-prompt-bar\n          " + /*self*/ ctx[1].getStyle("prompt-bar") + "\n        ")) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

// (72:8) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_class_value;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "type", "text");
			attr(input, "class", input_class_value = "\n              pnotify-prompt-input\n              " + /*self*/ ctx[1].getStyle("input") + "\n              " + /*promptClass*/ ctx[4] + "\n            ");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[17](input);
			set_input_value(input, /*promptValue*/ ctx[0]);

			dispose = [
				listen(input, "keypress", /*handleKeyPress*/ ctx[12]),
				listen(input, "input", /*input_input_handler*/ ctx[18])
			];
		},
		p(ctx, dirty) {
			if (dirty & /*self, promptClass*/ 18 && input_class_value !== (input_class_value = "\n              pnotify-prompt-input\n              " + /*self*/ ctx[1].getStyle("input") + "\n              " + /*promptClass*/ ctx[4] + "\n            ")) {
				attr(input, "class", input_class_value);
			}

			if (dirty & /*promptValue*/ 1 && input.value !== /*promptValue*/ ctx[0]) {
				set_input_value(input, /*promptValue*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			/*input_binding*/ ctx[17](null);
			run_all(dispose);
		}
	};
}

// (60:8) {#if promptMultiLine}
function create_if_block_3(ctx) {
	let textarea;
	let textarea_class_value;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			attr(textarea, "rows", "5");
			attr(textarea, "class", textarea_class_value = "\n              pnotify-prompt-input\n              " + /*self*/ ctx[1].getStyle("input") + "\n              " + /*promptClass*/ ctx[4] + "\n            ");
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding*/ ctx[15](textarea);
			set_input_value(textarea, /*promptValue*/ ctx[0]);

			dispose = [
				listen(textarea, "keypress", /*handleKeyPress*/ ctx[12]),
				listen(textarea, "input", /*textarea_input_handler*/ ctx[16])
			];
		},
		p(ctx, dirty) {
			if (dirty & /*self, promptClass*/ 18 && textarea_class_value !== (textarea_class_value = "\n              pnotify-prompt-input\n              " + /*self*/ ctx[1].getStyle("input") + "\n              " + /*promptClass*/ ctx[4] + "\n            ")) {
				attr(textarea, "class", textarea_class_value);
			}

			if (dirty & /*promptValue*/ 1) {
				set_input_value(textarea, /*promptValue*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) detach(textarea);
			/*textarea_binding*/ ctx[15](null);
			run_all(dispose);
		}
	};
}

// (105:52) {:else}
function create_else_block(ctx) {
	let t_value = /*button*/ ctx[21].text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*buttons*/ 128 && t_value !== (t_value = /*button*/ ctx[21].text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (105:9) {#if button.textTrusted}
function create_if_block_1(ctx) {
	let html_tag;
	let raw_value = /*button*/ ctx[21].text + "";

	return {
		c() {
			html_tag = new HtmlTag(raw_value, null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*buttons*/ 128 && raw_value !== (raw_value = /*button*/ ctx[21].text + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (95:6) {#each buttons as button}
function create_each_block(ctx) {
	let button;
	let button_class_value;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*button*/ ctx[21].textTrusted) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	function click_handler(...args) {
		return /*click_handler*/ ctx[19](/*button*/ ctx[21], ...args);
	}

	return {
		c() {
			button = element("button");
			if_block.c();
			attr(button, "type", "button");

			attr(button, "class", button_class_value = "\n            pnotify-action-button\n            " + /*self*/ ctx[1].getStyle("btn") + "\n            " + (/*button*/ ctx[21].primary
			? /*self*/ ctx[1].getStyle("btn-primary")
			: /*self*/ ctx[1].getStyle("btn-secondary")) + "\n            " + (/*button*/ ctx[21].addClass
			? /*button*/ ctx[21].addClass
			: "") + "\n          ");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if_block.m(button, null);
			dispose = listen(button, "click", click_handler);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(button, null);
				}
			}

			if (dirty & /*self, buttons*/ 130 && button_class_value !== (button_class_value = "\n            pnotify-action-button\n            " + /*self*/ ctx[1].getStyle("btn") + "\n            " + (/*button*/ ctx[21].primary
			? /*self*/ ctx[1].getStyle("btn-primary")
			: /*self*/ ctx[1].getStyle("btn-secondary")) + "\n            " + (/*button*/ ctx[21].addClass
			? /*button*/ ctx[21].addClass
			: "") + "\n          ")) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			if_block.d();
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = (/*confirm*/ ctx[2] || /*prompt*/ ctx[3]) && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*confirm*/ ctx[2] || /*prompt*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const position = "AppendContent";

const defaults = {
	// Make a confirmation box.
	confirm: false,
	// Make a prompt.
	prompt: false,
	// Classes to add to the input element of the prompt.
	promptClass: "",
	// The value of the prompt.
	promptValue: "",
	// Whether the prompt should accept multiple lines of text.
	promptMultiLine: false,
	// For confirmation boxes, true means the first button or the button with promptTrigger will be focused, and null means focus will change only for modal notices. For prompts, true or null means focus the prompt. When false, focus will not change.
	focus: null,
	// Where to align the buttons. (flex-start, center, flex-end, space-around, space-between)
	align: "flex-end",
	// The buttons to display, and their callbacks.
	buttons: [
		{
			text: "Ok",
			textTrusted: false,
			addClass: "",
			primary: true,
			// Whether to trigger this button when the user hits enter in a single line prompt. Also, focus the button if it is a modal prompt.
			promptTrigger: true,
			click: (notice, value) => {
				notice.close();
				notice.fire("pnotify:confirm", { notice, value });
			}
		},
		{
			text: "Cancel",
			textTrusted: false,
			addClass: "",
			click: notice => {
				notice.close();
				notice.fire("pnotify:cancel", { notice });
			}
		}
	]
};

function instance($$self, $$props, $$invalidate) {
	let { self = null } = $$props;
	let { confirm = defaults.confirm } = $$props;
	let { prompt = defaults.prompt } = $$props;
	let { promptClass = defaults.promptClass } = $$props;
	let { promptValue = defaults.promptValue } = $$props;
	let { promptMultiLine = defaults.promptMultiLine } = $$props;
	let { focus = defaults.focus } = $$props;
	let { align = defaults.align } = $$props;
	let { buttons = defaults.buttons } = $$props;
	let promptMultiElem;
	let promptSingleElem;
	let buttonsElem;
	let focusNextChange = false;

	self.on("pnotify:afterOpen", () => {
		$$invalidate(14, focusNextChange = true);
	});

	function handleClick(button, event) {
		if (button.click) {
			button.click(self, prompt ? promptValue : null, event);
		}
	}

	function handleKeyPress(event) {
		if (event.keyCode === 13 && !event.shiftKey) {
			event.preventDefault();
			const { buttons } = this.get();

			for (let i = 0; i < buttons.length; i++) {
				if (buttons[i].promptTrigger && buttons[i].click) {
					buttons[i].click(self, prompt ? promptValue : null, event);
				}
			}
		}
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(8, promptMultiElem = $$value);
		});
	}

	function textarea_input_handler() {
		promptValue = this.value;
		$$invalidate(0, promptValue);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(9, promptSingleElem = $$value);
		});
	}

	function input_input_handler() {
		promptValue = this.value;
		$$invalidate(0, promptValue);
	}

	const click_handler = (button, event) => handleClick(button, event);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			$$invalidate(10, buttonsElem = $$value);
		});
	}

	$$self.$set = $$props => {
		if ("self" in $$props) $$invalidate(1, self = $$props.self);
		if ("confirm" in $$props) $$invalidate(2, confirm = $$props.confirm);
		if ("prompt" in $$props) $$invalidate(3, prompt = $$props.prompt);
		if ("promptClass" in $$props) $$invalidate(4, promptClass = $$props.promptClass);
		if ("promptValue" in $$props) $$invalidate(0, promptValue = $$props.promptValue);
		if ("promptMultiLine" in $$props) $$invalidate(5, promptMultiLine = $$props.promptMultiLine);
		if ("focus" in $$props) $$invalidate(13, focus = $$props.focus);
		if ("align" in $$props) $$invalidate(6, align = $$props.align);
		if ("buttons" in $$props) $$invalidate(7, buttons = $$props.buttons);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*focusNextChange, prompt, focus, promptMultiLine, promptMultiElem, promptSingleElem, confirm, self, buttons, buttonsElem*/ 26542) {
			$: {
				if (focusNextChange) {
					if (prompt && focus !== false) {
						if (promptMultiLine) {
							if (promptMultiElem) {
								promptMultiElem.focus();
								$$invalidate(14, focusNextChange = false);
							}
						} else {
							if (promptSingleElem) {
								promptSingleElem.focus();
								$$invalidate(14, focusNextChange = false);
							}
						}
					} else if (confirm && (focus === true || focus === null && self.stack.modal === true)) {
						if (buttons.length && buttonsElem) {
							let i = buttons.length - 1;

							while (i > 0) {
								if (buttons[i].promptTrigger) {
									break;
								}

								i--;
							}

							buttonsElem.children[i].focus();
							$$invalidate(14, focusNextChange = false);
						}
					}
				}
			}
		}
	};

	return [
		promptValue,
		self,
		confirm,
		prompt,
		promptClass,
		promptMultiLine,
		align,
		buttons,
		promptMultiElem,
		promptSingleElem,
		buttonsElem,
		handleClick,
		handleKeyPress,
		focus,
		focusNextChange,
		textarea_binding,
		textarea_input_handler,
		input_binding,
		input_input_handler,
		click_handler,
		div0_binding
	];
}

class PNotifyConfirm extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			self: 1,
			confirm: 2,
			prompt: 3,
			promptClass: 4,
			promptValue: 0,
			promptMultiLine: 5,
			focus: 13,
			align: 6,
			buttons: 7
		});
	}
}

export default PNotifyConfirm;
export { position, defaults };
//# sourceMappingURL=PNotifyConfirm.js.map