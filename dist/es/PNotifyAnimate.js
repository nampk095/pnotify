/* src/PNotifyAnimate.svelte generated by Svelte v3.18.2 */
import { SvelteComponent, init, safe_not_equal } from "svelte/internal";

import { onDestroy } from "svelte";
const position = "PrependContainer";

const defaults = {
	// The class to use to animate the notice in. If only one of these is set,
	// it will be used for both.
	inClass: null,
	// The class to use to animate the notice out. If only one of these is set,
	// it will be used for both.
	outClass: null
};

function instance($$self, $$props, $$invalidate) {
	let { self = null } = $$props;
	let { inClass = defaults.inClass } = $$props;
	let { outClass = defaults.outClass } = $$props;
	let _animation = self.animation;
	let _animateIn = self.animateIn;
	let _animateOut = self.animateOut;

	onDestroy(() => {
		self.$set({
			animation: _animation,
			animateIn: _animateIn,
			animateOut: _animateOut
		});
	});

	self.on("pnotify:update", () => {
		if (self.refs.elem) {
			var animSpeed = 250;

			if (self.animateSpeed === "slow") {
				animSpeed = 400;
			} else if (self.animateSpeed === "fast") {
				animSpeed = 100;
			} else if (self.animateSpeed > 0) {
				animSpeed = self.animateSpeed;
			}

			animSpeed = animSpeed / 1000;

			if (self.refs.elem.style.animationDuration !== animSpeed + "s") {
				$$invalidate(0, self.refs.elem.style.animationDuration = animSpeed + "s", self);
			}
		}
	});

	function animateIn(callback, immediate) {
		// Declare that the notice is animating in.
		self.setAnimating("in");

		let off;

		const finished = event => {
			if (event && self.refs.elem && event.target !== self.refs.elem) {
				return;
			}

			off();
			self.setAnimatingClass("pnotify-in animated");

			if (callback) {
				callback.call();
			}

			// Declare that the notice has completed animating.
			self.setAnimating(false);
		};

		off = self.on("animationend", finished);

		if (immediate) {
			finished();
		} else {
			self.setAnimatingClass("pnotify-in animated " + (inClass || outClass));
		}
	}

	function animateOut(callback, immediate) {
		// Declare that the notice is animating out.
		self.setAnimating("out");

		let off;

		const finished = event => {
			if (event && self.refs.elem && event.target !== self.refs.elem) {
				return;
			}

			off();
			self.setAnimatingClass("animated");

			if (callback) {
				callback.call();
			}

			// Declare that the notice has completed animating.
			if (self.setAnimating) {
				self.setAnimating(false);
			}
		};

		off = self.on("animationend", finished);

		if (immediate) {
			finished();
		} else {
			self.setAnimatingClass("pnotify-in animated " + (outClass || inClass));
		}
	}

	self.attention = (aniClass, callback) => {
		let off;

		const cb = () => {
			off();
			self.removeModuleClass("container", "animated", aniClass);

			if (callback) {
				callback.call(self);
			}
		};

		off = self.on("animationend", cb);
		self.addModuleClass("container", "animated", aniClass);
	};

	$$self.$set = $$props => {
		if ("self" in $$props) $$invalidate(0, self = $$props.self);
		if ("inClass" in $$props) $$invalidate(1, inClass = $$props.inClass);
		if ("outClass" in $$props) $$invalidate(2, outClass = $$props.outClass);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*inClass, outClass, self*/ 7) {
			$: if (inClass || outClass) {
				self.$set({ animation: "none", animateIn, animateOut });
			} else {
				self.$set({
					animation: _animation,
					animateIn: _animateIn,
					animateOut: _animateOut
				});
			}
		}
	};

	return [self, inClass, outClass];
}

class PNotifyAnimate extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, null, safe_not_equal, { self: 0, inClass: 1, outClass: 2 });
	}
}

export default PNotifyAnimate;
export { position, defaults };
//# sourceMappingURL=PNotifyAnimate.js.map