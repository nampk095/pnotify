/* src/PNotifyCoreComponent.html generated by Svelte v3.18.2 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	flush,
	get_spread_object,
	get_spread_update,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	outro_and_destroy_block,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text as text_1,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

import Stack from "./Stack.js";
import { onMount, beforeUpdate, tick, createEventDispatcher } from "svelte";
import { current_component } from "svelte/internal";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[113] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[113] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[113] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[113] = list[i];
	return child_ctx;
}

// (235:4) {#each modulesPrependContainer as module (module.key)}
function create_each_block_3(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[28] }, /*modules*/ ctx[14][/*module*/ ctx[113].key]];
	var switch_value = /*module*/ ctx[113];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*self, modules*/ 268451840)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 268435456 && { self: /*self*/ ctx[28] },
					dirty[0] & /*modules*/ 16384 && get_spread_object(/*modules*/ ctx[14][/*module*/ ctx[113].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[113])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (238:4) {#if icon !== false}
function create_if_block_6(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;

	return {
		c() {
			div = element("div");
			span = element("span");

			attr(span, "class", span_class_value = /*icon*/ ctx[0] === true
			? /*getIcon*/ ctx[16](/*type*/ ctx[3])
			: /*icon*/ ctx[0]);

			attr(div, "class", div_class_value = "ui-pnotify-icon " + /*getStyle*/ ctx[15]("icon"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			/*div_binding*/ ctx[107](div);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon, type*/ 9 && span_class_value !== (span_class_value = /*icon*/ ctx[0] === true
			? /*getIcon*/ ctx[16](/*type*/ ctx[3])
			: /*icon*/ ctx[0])) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[107](null);
		}
	};
}

// (244:6) {#each modulesPrependContent as module (module.key)}
function create_each_block_2(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[28] }, /*modules*/ ctx[14][/*module*/ ctx[113].key]];
	var switch_value = /*module*/ ctx[113];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*self, modules*/ 268451840)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 268435456 && { self: /*self*/ ctx[28] },
					dirty[0] & /*modules*/ 16384 && get_spread_object(/*modules*/ ctx[14][/*module*/ ctx[113].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[113])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (247:6) {#if title !== false}
function create_if_block_3(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_titleElement*/ ctx[26] && create_if_block_4(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "ui-pnotify-title " + /*getStyle*/ ctx[15]("title"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_1*/ ctx[108](div);
		},
		p(ctx, dirty) {
			if (!/*_titleElement*/ ctx[26]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_1*/ ctx[108](null);
		}
	};
}

// (249:10) {#if !_titleElement}
function create_if_block_4(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*titleTrusted*/ ctx[5]) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (252:12) {:else}
function create_else_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*title*/ ctx[4]);
			attr(span, "class", "ui-pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 16) set_data(t, /*title*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (250:12) {#if titleTrusted}
function create_if_block_5(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*title*/ ctx[4], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 16) html_tag.p(/*title*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (258:6) {#if text !== false}
function create_if_block(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_textElement*/ ctx[27] && create_if_block_1(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "ui-pnotify-text " + /*getStyle*/ ctx[15]("text"));
			attr(div, "style", /*_maxTextHeightStyle*/ ctx[25]);
			attr(div, "role", "alert");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_2*/ ctx[109](div);
		},
		p(ctx, dirty) {
			if (!/*_textElement*/ ctx[27]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*_maxTextHeightStyle*/ 33554432) {
				attr(div, "style", /*_maxTextHeightStyle*/ ctx[25]);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_2*/ ctx[109](null);
		}
	};
}

// (263:10) {#if !_textElement}
function create_if_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*textTrusted*/ ctx[7]) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (266:12) {:else}
function create_else_block(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*text*/ ctx[6]);
			attr(span, "class", "ui-pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 64) set_data(t, /*text*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (264:12) {#if textTrusted}
function create_if_block_2(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*text*/ ctx[6], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 64) html_tag.p(/*text*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (272:6) {#each modulesAppendContent as module (module.key)}
function create_each_block_1(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[28] }, /*modules*/ ctx[14][/*module*/ ctx[113].key]];
	var switch_value = /*module*/ ctx[113];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*self, modules*/ 268451840)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 268435456 && { self: /*self*/ ctx[28] },
					dirty[0] & /*modules*/ 16384 && get_spread_object(/*modules*/ ctx[14][/*module*/ ctx[113].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[113])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (276:4) {#each modulesAppendContainer as module (module.key)}
function create_each_block(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ self: /*self*/ ctx[28] }, /*modules*/ ctx[14][/*module*/ ctx[113].key]];
	var switch_value = /*module*/ ctx[113];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*self, modules*/ 268451840)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 268435456 && { self: /*self*/ ctx[28] },
					dirty[0] & /*modules*/ 16384 && get_spread_object(/*modules*/ ctx[14][/*module*/ ctx[113].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[113])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div1;
	let each_blocks_3 = [];
	let each0_lookup = new Map();
	let t0;
	let t1;
	let div0;
	let each_blocks_2 = [];
	let each1_lookup = new Map();
	let t2;
	let t3;
	let t4;
	let each_blocks_1 = [];
	let each2_lookup = new Map();
	let div0_class_value;
	let t5;
	let each_blocks = [];
	let each3_lookup = new Map();
	let div1_class_value;
	let div1_style_value;
	let div2_class_value;
	let current;
	let dispose;
	let each_value_3 = modulesPrependContainer;
	const get_key = ctx => /*module*/ ctx[113].key;

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_3[i] = create_each_block_3(key, child_ctx));
	}

	let if_block0 = /*icon*/ ctx[0] !== false && create_if_block_6(ctx);
	let each_value_2 = modulesPrependContent;
	const get_key_1 = ctx => /*module*/ ctx[113].key;

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
	}

	let if_block1 = /*title*/ ctx[4] !== false && create_if_block_3(ctx);
	let if_block2 = /*text*/ ctx[6] !== false && create_if_block(ctx);
	let each_value_1 = modulesAppendContent;
	const get_key_2 = ctx => /*module*/ ctx[113].key;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = modulesAppendContainer;
	const get_key_3 = ctx => /*module*/ ctx[113].key;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_3(child_ctx);
		each3_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t5 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = "ui-pnotify-content " + /*getStyle*/ ctx[15]("content"));
			attr(div1, "class", div1_class_value = "\n        ui-pnotify-container\n        " + /*getStyle*/ ctx[15]("container") + "\n        " + /*getStyle*/ ctx[15](/*type*/ ctx[3]) + "\n        " + /*cornerClass*/ ctx[10] + "\n        " + (/*shadow*/ ctx[13] ? "ui-pnotify-shadow" : "") + "\n        " + /*_moduleClasses*/ ctx[20].container.join(" ") + "\n      ");
			attr(div1, "style", div1_style_value = "" + (/*_widthStyle*/ ctx[23] + " " + /*_minHeightStyle*/ ctx[24]));
			attr(div1, "role", "alert");
			attr(div2, "aria-live", "assertive");
			attr(div2, "role", "alertdialog");
			attr(div2, "ui-pnotify", "");

			attr(div2, "class", div2_class_value = "\n      ui-pnotify\n      " + (/*icon*/ ctx[0] !== false ? "ui-pnotify-with-icon" : "") + "\n      " + /*getStyle*/ ctx[15]("element") + "\n      ui-pnotify-mode-" + /*mode*/ ctx[8] + "\n      " + /*addClass*/ ctx[9] + "\n      " + /*_animatingClass*/ ctx[18] + "\n      " + /*_moveClass*/ ctx[19] + "\n      " + (/*animation*/ ctx[11] === "fade"
			? "ui-pnotify-fade-" + /*animateSpeed*/ ctx[12]
			: "") + "\n      " + (/*stack*/ ctx[1] && (/*stack*/ ctx[1].modal === true || /*stack*/ ctx[1].modal === "ish" && /*_timer*/ ctx[17] === "prevented")
			? "ui-pnotify-modal"
			: "") + "\n      " + (/*_masking*/ ctx[21]
			? "ui-pnotify-masking ui-pnotify-masking-" + /*_masking*/ ctx[21]
			: "") + "\n      " + (/*_maskingIn*/ ctx[22] ? "ui-pnotify-masking-in" : "") + "\n      " + /*_moduleClasses*/ ctx[20].elem.join(" ") + "\n    ");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].m(div1, null);
			}

			append(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			append(div1, div0);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].m(div0, null);
			}

			append(div0, t2);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t3);
			if (if_block2) if_block2.m(div0, null);
			append(div0, t4);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			/*div0_binding*/ ctx[110](div0);
			append(div1, t5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			/*div1_binding*/ ctx[111](div1);
			/*div2_binding*/ ctx[112](div2);
			current = true;

			dispose = [
				listen(div2, "mouseenter", /*handleInteraction*/ ctx[29]),
				listen(div2, "mouseleave", /*handleLeaveInteraction*/ ctx[30]),
				listen(div2, "focusin", /*handleInteraction*/ ctx[29]),
				listen(div2, "focusout", /*handleLeaveInteraction*/ ctx[30]),
				listen(div2, "pnotify:init", /*pnotify_init_handler*/ ctx[81]),
				listen(div2, "pnotify:mount", /*pnotify_mount_handler*/ ctx[82]),
				listen(div2, "pnotify:update", /*pnotify_update_handler*/ ctx[83]),
				listen(div2, "pnotify:beforeOpen", /*pnotify_beforeOpen_handler*/ ctx[84]),
				listen(div2, "pnotify:afterOpen", /*pnotify_afterOpen_handler*/ ctx[85]),
				listen(div2, "pnotify:beforeClose", /*pnotify_beforeClose_handler*/ ctx[86]),
				listen(div2, "pnotify:afterClose", /*pnotify_afterClose_handler*/ ctx[87]),
				listen(div2, "pnotify:beforeDestroy", /*pnotify_beforeDestroy_handler*/ ctx[88]),
				listen(div2, "pnotify:afterDestroy", /*pnotify_afterDestroy_handler*/ ctx[89]),
				listen(div2, "mouseover", /*mouseover_handler*/ ctx[79]),
				listen(div2, "mouseout", /*mouseout_handler*/ ctx[90]),
				listen(div2, "mouseenter", /*mouseenter_handler*/ ctx[91]),
				listen(div2, "mouseleave", /*mouseleave_handler*/ ctx[92]),
				listen(div2, "mousemove", /*mousemove_handler*/ ctx[93]),
				listen(div2, "mousedown", /*mousedown_handler*/ ctx[94]),
				listen(div2, "mouseup", /*mouseup_handler*/ ctx[95]),
				listen(div2, "click", /*click_handler*/ ctx[96]),
				listen(div2, "dblclick", /*dblclick_handler*/ ctx[97]),
				listen(div2, "focus", /*focus_handler*/ ctx[98]),
				listen(div2, "blur", /*blur_handler*/ ctx[99]),
				listen(div2, "focusin", /*focusin_handler*/ ctx[100]),
				listen(div2, "focusout", /*focusout_handler*/ ctx[101]),
				listen(div2, "touchstart", /*touchstart_handler*/ ctx[102]),
				listen(div2, "touchmove", /*touchmove_handler*/ ctx[103]),
				listen(div2, "touchend", /*touchend_handler*/ ctx[104]),
				listen(div2, "touchcancel", /*touchcancel_handler*/ ctx[105]),
				listen(div2, "animationend", /*animationend_handler*/ ctx[106]),
				listen(div2, "transitionend", /*transitionend_handler*/ ctx[80])
			];
		},
		p(ctx, dirty) {
			const each_value_3 = modulesPrependContainer;
			group_outros();
			each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, div1, outro_and_destroy_block, create_each_block_3, t0, get_each_context_3);
			check_outros();

			if (/*icon*/ ctx[0] !== false) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			const each_value_2 = modulesPrependContent;
			group_outros();
			each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, div0, outro_and_destroy_block, create_each_block_2, t2, get_each_context_2);
			check_outros();

			if (/*title*/ ctx[4] !== false) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(div0, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*text*/ ctx[6] !== false) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					if_block2.m(div0, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			const each_value_1 = modulesAppendContent;
			group_outros();
			each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx, each_value_1, each2_lookup, div0, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
			check_outros();
			const each_value = modulesAppendContainer;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key_3, 1, ctx, each_value, each3_lookup, div1, outro_and_destroy_block, create_each_block, null, get_each_context);
			check_outros();

			if (!current || dirty[0] & /*type, cornerClass, shadow, _moduleClasses*/ 1057800 && div1_class_value !== (div1_class_value = "\n        ui-pnotify-container\n        " + /*getStyle*/ ctx[15]("container") + "\n        " + /*getStyle*/ ctx[15](/*type*/ ctx[3]) + "\n        " + /*cornerClass*/ ctx[10] + "\n        " + (/*shadow*/ ctx[13] ? "ui-pnotify-shadow" : "") + "\n        " + /*_moduleClasses*/ ctx[20].container.join(" ") + "\n      ")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*_widthStyle, _minHeightStyle*/ 25165824 && div1_style_value !== (div1_style_value = "" + (/*_widthStyle*/ ctx[23] + " " + /*_minHeightStyle*/ ctx[24]))) {
				attr(div1, "style", div1_style_value);
			}

			if (!current || dirty[0] & /*icon, mode, addClass, _animatingClass, _moveClass, animation, animateSpeed, stack, _timer, _masking, _maskingIn, _moduleClasses*/ 8264451 && div2_class_value !== (div2_class_value = "\n      ui-pnotify\n      " + (/*icon*/ ctx[0] !== false ? "ui-pnotify-with-icon" : "") + "\n      " + /*getStyle*/ ctx[15]("element") + "\n      ui-pnotify-mode-" + /*mode*/ ctx[8] + "\n      " + /*addClass*/ ctx[9] + "\n      " + /*_animatingClass*/ ctx[18] + "\n      " + /*_moveClass*/ ctx[19] + "\n      " + (/*animation*/ ctx[11] === "fade"
			? "ui-pnotify-fade-" + /*animateSpeed*/ ctx[12]
			: "") + "\n      " + (/*stack*/ ctx[1] && (/*stack*/ ctx[1].modal === true || /*stack*/ ctx[1].modal === "ish" && /*_timer*/ ctx[17] === "prevented")
			? "ui-pnotify-modal"
			: "") + "\n      " + (/*_masking*/ ctx[21]
			? "ui-pnotify-masking ui-pnotify-masking-" + /*_masking*/ ctx[21]
			: "") + "\n      " + (/*_maskingIn*/ ctx[22] ? "ui-pnotify-masking-in" : "") + "\n      " + /*_moduleClasses*/ ctx[20].elem.join(" ") + "\n    ")) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks_3[i]);
			}

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks_3.length; i += 1) {
				transition_out(each_blocks_3[i]);
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].d();
			}

			if (if_block0) if_block0.d();

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d();
			}

			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			/*div0_binding*/ ctx[110](null);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div1_binding*/ ctx[111](null);
			/*div2_binding*/ ctx[112](null);
			run_all(dispose);
		}
	};
}

let posTimer;

// These actions need to be done once the DOM is ready.
function onDocumentLoaded() {
	defaultStack.context = document.body;

	// Reposition the notices when the window resizes.
	window.addEventListener("resize", () => {
		// This timer is used for queueing the position event so it doesn't run
		// repeatedly.
		if (posTimer) {
			clearTimeout(posTimer);
		}

		posTimer = setTimeout(
			() => {
				const event = new Event("pnotify:position");
				document.body.dispatchEvent(event);
				posTimer = null;
			},
			10
		);
	});
}

const defaultStack = new Stack({
		dir1: "down",
		dir2: "left",
		firstpos1: 25,
		firstpos2: 25,
		spacing1: 36,
		spacing2: 36,
		push: "bottom"
	});

const defaults = {
	// Type of the notice. 'notice', 'info', 'success', or 'error'.
	type: "notice",
	// The notice's title. Can be a string, an element, or `false` for no title.
	title: false,
	// Whether to trust the title or escape its contents. (Not allow HTML.)
	titleTrusted: false,
	// The notice's text. Can be a string, an element, or `false` for no text.
	text: false,
	// Whether to trust the text or escape its contents. (Not allow HTML.)
	textTrusted: false,
	// What styling classes to use. (Can be 'brighttheme', 'material',
	// 'bootstrap3', 'bootstrap4', or a styling object.)
	styling: "brighttheme",
	// What icons to use (Can be 'brighttheme', 'material', 'bootstrap3',
	// 'fontawesome4', 'fontawesome5', or an icon object.)
	icons: "brighttheme",
	// Light or dark version of the theme, if supported by the styling. This
	// overrides the CSS media query when a preference is given. (Can be
	// 'no-preference', 'light', or 'dark'.)
	mode: "no-preference",
	// Additional classes to be added to the notice. (For custom styling.)
	addClass: "",
	// Class to be added to the notice for corner styling.
	cornerClass: "",
	// Display the notice immediately when it is created.
	autoOpen: true,
	// Width of the notice.
	width: "360px",
	// Minimum height of the notice. It will expand to fit content.
	minHeight: "16px",
	// Maximum height of the text container. If the text goes beyond this
	// height, scrollbars will appear. Use null to remove this restriction.
	maxTextHeight: "200px",
	// Set icon to true to use the default icon for the selected
	// style/type, false for no icon, or a string for your own icon class.
	icon: true,
	// The animation to use when displaying and hiding the notice. 'none'
	// and 'fade' are supported through CSS. Others are supported
	// through the Animate module and Animate.css.
	animation: "fade",
	// Speed at which the notice animates in and out. 'slow', 'normal',
	// or 'fast'. Respectively, 400ms, 250ms, 100ms.
	animateSpeed: "normal",
	// Display a drop shadow.
	shadow: true,
	// After a delay, remove the notice.
	hide: true,
	// Delay in milliseconds before the notice is removed.
	delay: 8000,
	// Reset the hide timer if the mouse moves over the notice.
	mouseReset: true,
	// Remove the notice's elements from the DOM after it is removed.
	remove: true,
	// Whether to remove the notice from the stack array (and therefore,
	// history) when it is closed.
	destroy: true,
	// The stack on which the notices will be placed. Also controls the
	// direction the notices stack.
	stack: defaultStack,
	// This is where options for modules should be defined.
	modules: {}
};

// This object holds all the PNotify modules. They are used to provide
// additional functionality.
const moduleRegistry = {};

const modulesPrependContainer = [];
const modulesAppendContainer = [];
const modulesPrependContent = [];
const modulesAppendContent = [];

const styleRegistry = {
	bootstrap3: {
		container: "alert",
		notice: "alert-warning",
		info: "alert-info",
		success: "alert-success",
		error: "alert-danger"
	},
	bootstrap4: {
		container: "alert",
		notice: "alert-warning",
		info: "alert-info",
		success: "alert-success",
		error: "alert-danger"
	}
};

// icons are separate from the style, since bs4 doesn't come with any
const iconRegistry = {
	bootstrap3: {
		notice: "glyphicon glyphicon-exclamation-sign",
		info: "glyphicon glyphicon-info-sign",
		success: "glyphicon glyphicon-ok-sign",
		error: "glyphicon glyphicon-warning-sign"
	},
	// User must have Font Awesome v4.0+
	fontawesome4: {
		notice: "fa fa-exclamation-circle",
		info: "fa fa-info-circle",
		success: "fa fa-check-circle",
		error: "fa fa-exclamation-triangle"
	},
	// User must have Font Awesome v5.0+
	fontawesome5: {
		notice: "fas fa-exclamation-circle",
		info: "fas fa-info-circle",
		success: "fas fa-check-circle",
		error: "fas fa-exclamation-triangle"
	}
};

// Run the deferred actions once the DOM is ready.
if (window && document.body) {
	onDocumentLoaded();
} else {
	document.addEventListener("DOMContentLoaded", onDocumentLoaded);
}

function instance($$self, $$props, $$invalidate) {
	const self = current_component;
	const dispatch = createEventDispatcher();
	let { type = defaults.type } = $$props;
	let { title = defaults.title } = $$props;
	let { titleTrusted = defaults.titleTrusted } = $$props;
	let { text = defaults.text } = $$props;
	let { textTrusted = defaults.textTrusted } = $$props;
	let { styling = defaults.styling } = $$props;
	let { icons = defaults.icons } = $$props;
	let { mode = defaults.mode } = $$props;
	let { addClass = defaults.addClass } = $$props;
	let { cornerClass = defaults.cornerClass } = $$props;
	let { autoOpen = defaults.autoOpen } = $$props;
	let { width = defaults.width } = $$props;
	let { minHeight = defaults.minHeight } = $$props;
	let { maxTextHeight = defaults.maxTextHeight } = $$props;
	let { icon = defaults.icon } = $$props;
	let { animation = defaults.animation } = $$props;
	let { animateSpeed = defaults.animateSpeed } = $$props;
	let { shadow = defaults.shadow } = $$props;
	let { hide = defaults.hide } = $$props;
	let { delay = defaults.delay } = $$props;
	let { mouseReset = defaults.mouseReset } = $$props;
	let { remove = defaults.remove } = $$props;
	let { destroy = defaults.destroy } = $$props;
	let { stack = defaults.stack } = $$props;
	let { modules = Object.assign({}, defaults.modules) } = $$props;

	const refs = {
		elem: null,
		container: null,
		content: null,
		iconContainer: null,
		titleContainer: null,
		textContainer: null
	};

	// The state can be 'waiting', 'opening', 'open', 'closing', or 'closed'.
	let _state = "closed";

	// Auto close timer.
	let _timer = null;

	// Animation timers.
	let _animInTimer = null;

	let _animOutTimer = null;

	// Stores what is currently being animated (in or out).
	let _animating = false;

	// Stores the class that adds entry/exit animation effects.
	let _animatingClass = "";

	// Stores the class that adds movement animation effects.
	let _moveClass = "";

	// Stores whether the notice was hidden by a timer.
	let _timerHide = false;

	// Holds classes that modules add for the notice element or container element.
	let _moduleClasses = { elem: [], container: [] };

	// Modules that change how the notice displays (causing the notice element to
	// not appear) can set this to true to make PNotify assume the notice has
	// opened.
	let _moduleIsNoticeOpen = false;

	// The masking control for the second notice in a modalish stack when the
	// first notice is hovered.
	let _masking = false;

	let _maskingIn = false;
	let _maskingTimer = null;

	// These hold the instances to the Svelte-loaded modules.
	// const _modulesPrependContainerInstances = [];
	// const _modulesAppendContainerInstances = [];
	// This keeps the beforeUpdate handler from going into a loop when we're
	// taming Font Awesome's magic.
	let _updatingIcon = false;

	// Save the old value of hide and icon, so we can do our magic.
	let _oldHide = hide;

	let _oldIcon = icon;
	const getState = () => _state;

	const getStyle = name => _styles && name in _styles
	? _styles[name]
	: styling + "-" + name;

	const getIcon = name => _icons && name in _icons
	? _icons[name]
	: icons + "-icon-" + name;

	beforeUpdate(async () => {
		if (_updatingIcon) {
			return;
		}

		dispatchLifecycleEvent("update");

		// Update the timed hiding.
		if (_state !== "closed" && _state !== "waiting" && hide !== _oldHide) {
			if (!hide) {
				cancelClose();
			} else if (!_oldHide) {
				queueClose();
			}
		}

		// Queue a position
		if (_state !== "closed" && _state !== "closing" && stack && !stack._collapsingModalState) {
			stack.queuePosition();
		}

		// Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
		// In order to make it play nice with Svelte, we have to clear the element
		// and make it again.
		if (icon !== _oldIcon && (icon === true && icons === "fontawesome5" || typeof icon === "string" && icon.match(/(^| )fa[srlb]($| )/))) {
			const newIcon = icon;
			$$invalidate(0, icon = false);
			_updatingIcon = true;
			await tick();
			$$invalidate(0, icon = newIcon);
			_updatingIcon = false;
		}

		// Save old options.
		_oldHide = hide;

		_oldIcon = icon;
	});

	let _oldStack = NaN;

	onMount(() => {
		dispatchLifecycleEvent("mount");

		// Display the notice.
		if (autoOpen) {
			open();
		}
	});

	function handleInteraction(e) {
		// Stop animation, reset the removal timer when the user interacts.
		if (mouseReset && _state === "closing") {
			if (!_timerHide) {
				return;
			}

			cancelClose();
		}

		// Stop the close timer.
		if (hide && mouseReset) {
			cancelClose();
		}
	}

	function handleLeaveInteraction(e) {
		// Start the close timer.
		if (hide && mouseReset && _animating !== "out") {
			queueClose();
		}
	}

	// This runs an event on all the modules.
	function dispatchLifecycleEvent(event, detail = {}) {
		const eventDetail = { notice: self, ...detail };
		let target = refs.elem || stack && stack.context || document.body;

		if (!target) {
			dispatch("pnotify:" + event, eventDetail);
			return true;
		}

		const eventObj = new Event("pnotify:" + event,
		{
				bubbles: event === "init" || event === "mount",
				cancelable: event.startsWith("before")
			});

		eventObj.detail = eventDetail;
		target.dispatchEvent(eventObj);
		return !eventObj.defaultPrevented;
	}

	function insertIntoDOM() {
		// If the notice is not in the DOM, or in the wrong context, append it.
		const target = stack && stack.context || document.body;

		if (!target) {
			throw new Error("No context to insert this notice into.");
		}

		if (!refs.elem) {
			throw new Error("Trying to insert notice before element is available.");
		}

		if (refs.elem.parentNode !== target) {
			target.appendChild(refs.elem);
		}
	}

	function removeFromDOM() {
		refs.elem && refs.elem.parentNode.removeChild(refs.elem);
	}

	let { open = immediate => {
		if (_state === "opening") {
			return;
		}

		if (_state === "open") {
			if (hide) {
				queueClose();
			}

			return;
		}

		if (stack && stack._shouldNoticeWait()) {
			_state = "waiting";
			return;
		}

		if (!dispatchLifecycleEvent("beforeOpen", { immediate })) {
			return;
		}

		_state = "opening";
		$$invalidate(21, _masking = false);

		// This makes the notice visibity: hidden; so its dimensions can be
		// determined.
		$$invalidate(18, _animatingClass = "ui-pnotify-initial-hidden");

		const afterOpenCallback = () => {
			// Now set it to hide.
			if (hide) {
				queueClose();
			}

			_state = "open";
			dispatchLifecycleEvent("afterOpen", { immediate });
		};

		if (stack) {
			// Notify the stack that a notice has opened.
			stack._handleNoticeOpened(self);
		}

		if (_moduleIsNoticeOpen) {
			afterOpenCallback();
			return;
		}

		insertIntoDOM();

		// Wait until the DOM is updated.
		window.requestAnimationFrame(() => {
			if (_state !== "opening") {
				return;
			}

			if (stack) {
				// Mark the stack so it won't animate the new notice.
				$$invalidate(1, stack._animation = false, stack);

				if (stack.push === "top") {
					// Reset the position data so the notice is positioned as the first
					// notice.
					stack._resetPositionData();
				}

				// Now position the stack's the notices.
				stack._positionNotice(self);

				stack.queuePosition(0);

				// Reset animation.
				$$invalidate(1, stack._animation = true, stack);
			}

			animateIn(afterOpenCallback, immediate);
		});
	} } = $$props;

	let { close = (immediate, timerHide, waitAfterward) => {
		if (_state === "closing" || _state === "closed") {
			return;
		}

		const runDestroy = () => {
			if (!dispatchLifecycleEvent("beforeDestroy")) {
				return;
			}

			if (stack) {
				stack._removeNotice(self);
			}

			self.$destroy();
			dispatchLifecycleEvent("afterDestroy");
		};

		if (_state === "waiting") {
			if (waitAfterward) {
				return;
			}

			_state = "closed";

			// It's debatable whether the notice should be destroyed in this case, but
			// I'm going to go ahead and say yes.
			if (destroy && !waitAfterward) {
				runDestroy();
			}

			return;
		}

		if (!dispatchLifecycleEvent("beforeClose", { immediate, timerHide, waitAfterward })) {
			return;
		}

		_state = "closing";
		_timerHide = !!timerHide; // Make sure it's a boolean.

		if (_timer && _timer !== "prevented" && clearTimeout) {
			clearTimeout(_timer);
		}

		$$invalidate(17, _timer = null);

		animateOut(
			() => {
				_timerHide = false;
				_state = waitAfterward ? "waiting" : "closed";
				dispatchLifecycleEvent("afterClose", { immediate, timerHide, waitAfterward });

				if (stack) {
					stack._handleNoticeClosed(self);
				}

				if (destroy && !waitAfterward) {
					// If we're supposed to destroy the notice, run the destroy module
					// events, remove from stack, and let Svelte handle DOM removal.
					runDestroy();
				} else if (remove && !waitAfterward) {
					// If we're supposed to remove the notice from the DOM, do it.
					removeFromDOM();
				}
			},
			immediate
		);
	} } = $$props;

	let { animateIn = async (callback, immediate) => {
		// Declare that the notice is animating in.
		_animating = "in";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animInTimer) {
				clearTimeout(_animInTimer);
			}

			if (_animating !== "in") {
				return;
			}

			let visible = _moduleIsNoticeOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (visible) {
				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				_animInTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(18, _animatingClass = "ui-pnotify-in");
			await tick();
			$$invalidate(18, _animatingClass = "ui-pnotify-in ui-pnotify-fade-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animInTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(18, _animatingClass = "ui-pnotify-in");
			await tick();
			finished();
		}
	} } = $$props;

	let { animateOut = async (callback, immediate) => {
		// Declare that the notice is animating out.
		_animating = "out";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animOutTimer) {
				clearTimeout(_animOutTimer);
			}

			if (_animating !== "out") {
				return;
			}

			let visible = _moduleIsNoticeOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === "0" || !visible) {
				$$invalidate(18, _animatingClass = "");

				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				// In case this was called before the notice finished animating.
				_animOutTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(18, _animatingClass = "ui-pnotify-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animOutTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(18, _animatingClass = "");
			await tick();
			finished();
		}
	} } = $$props;

	function cancelClose() {
		if (_timer && _timer !== "prevented") {
			clearTimeout(_timer);
		}

		if (_animOutTimer) {
			clearTimeout(_animOutTimer);
		}

		if (_state === "closing") {
			// If it's animating out, stop it.
			_state = "open";

			_animating = false;

			$$invalidate(18, _animatingClass = animation === "fade"
			? "ui-pnotify-in ui-pnotify-fade-in"
			: "ui-pnotify-in");
		}
	}

	function queueClose() {
		if (_timer === "prevented") {
			return;
		}

		// Cancel any current close timer.
		cancelClose();

		$$invalidate(17, _timer = setTimeout(() => close(false, true), isNaN(delay) ? 0 : delay));
	}

	function _preventTimerClose(prevent) {
		if (prevent) {
			cancelClose();
			$$invalidate(17, _timer = "prevented");
		} else if (_timer === "prevented") {
			$$invalidate(17, _timer = null);

			if (_state === "open" && hide) {
				queueClose();
			}
		}
	}

	function fire(name, detail) {
		dispatch(name, detail);
	}

	function addModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				_moduleClasses[element].push(className);
			}
		}

		$$invalidate(20, _moduleClasses);
	}

	function removeModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];
			const idx = _moduleClasses[element].indexOf(className);

			if (idx !== -1) {
				_moduleClasses[element].splice(idx, 1);
			}
		}

		$$invalidate(20, _moduleClasses);
	}

	function hasModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				return false;
			}
		}

		return true;
	}

	function getModuleIsNoticeOpen() {
		return _moduleIsNoticeOpen;
	}

	function setModuleIsNoticeOpen(value) {
		return _moduleIsNoticeOpen = value;
	}

	function setAnimating(value) {
		return _animating = value;
	}

	function getAnimatingClass() {
		return _animatingClass;
	}

	function setAnimatingClass(value) {
		return $$invalidate(18, _animatingClass = value);
	}

	function _getMoveClass() {
		return _moveClass;
	}

	function _setMoveClass(value) {
		return $$invalidate(19, _moveClass = value);
	}

	async function _setMasking(value, immediate, callback) {
		if (_maskingTimer) {
			clearTimeout(_maskingTimer);
		}

		if (_masking === value) {
			return;
		}

		if (value) {
			$$invalidate(21, _masking = value);
			$$invalidate(22, _maskingIn = !!immediate);
			insertIntoDOM();
			await tick();

			window.requestAnimationFrame(() => {
				if (_masking) {
					if (immediate && callback) {
						callback();
					} else {
						$$invalidate(22, _maskingIn = true);

						const finished = () => {
							refs.elem && refs.elem.removeEventListener("transitionend", finished);

							if (_maskingTimer) {
								clearTimeout(_maskingTimer);
							}

							if (_maskingIn && callback) {
								callback();
							}
						};

						refs.elem && refs.elem.addEventListener("transitionend", finished);
						_maskingTimer = setTimeout(finished, 650);
					}
				}
			});
		} else if (immediate) {
			$$invalidate(21, _masking = false);
			$$invalidate(22, _maskingIn = false);

			if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
				removeFromDOM();
			}

			if (callback) {
				callback();
			}
		} else {
			const finished = () => {
				refs.elem && refs.elem.removeEventListener("transitionend", finished);

				if (_maskingTimer) {
					clearTimeout(_maskingTimer);
				}

				if (!_maskingIn) {
					$$invalidate(21, _masking = false);

					if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
						removeFromDOM();
					}

					if (callback) {
						callback();
					}
				}
			};

			$$invalidate(22, _maskingIn = false);
			refs.elem && refs.elem.addEventListener("transitionend", finished);

			// eslint-disable-next-line no-unused-expressions
			refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.

			// Just in case the event doesn't fire, call it after 650 ms.
			_maskingTimer = setTimeout(finished, 650);
		}
	}

	dispatchLifecycleEvent("init");

	function mouseover_handler(event) {
		bubble($$self, event);
	}

	function transitionend_handler(event) {
		bubble($$self, event);
	}

	function pnotify_init_handler(event) {
		bubble($$self, event);
	}

	function pnotify_mount_handler(event) {
		bubble($$self, event);
	}

	function pnotify_update_handler(event) {
		bubble($$self, event);
	}

	function pnotify_beforeOpen_handler(event) {
		bubble($$self, event);
	}

	function pnotify_afterOpen_handler(event) {
		bubble($$self, event);
	}

	function pnotify_beforeClose_handler(event) {
		bubble($$self, event);
	}

	function pnotify_afterClose_handler(event) {
		bubble($$self, event);
	}

	function pnotify_beforeDestroy_handler(event) {
		bubble($$self, event);
	}

	function pnotify_afterDestroy_handler(event) {
		bubble($$self, event);
	}

	function mouseout_handler(event) {
		bubble($$self, event);
	}

	function mouseenter_handler(event) {
		bubble($$self, event);
	}

	function mouseleave_handler(event) {
		bubble($$self, event);
	}

	function mousemove_handler(event) {
		bubble($$self, event);
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function dblclick_handler(event) {
		bubble($$self, event);
	}

	function focus_handler(event) {
		bubble($$self, event);
	}

	function blur_handler(event) {
		bubble($$self, event);
	}

	function focusin_handler(event) {
		bubble($$self, event);
	}

	function focusout_handler(event) {
		bubble($$self, event);
	}

	function touchstart_handler(event) {
		bubble($$self, event);
	}

	function touchmove_handler(event) {
		bubble($$self, event);
	}

	function touchend_handler(event) {
		bubble($$self, event);
	}

	function touchcancel_handler(event) {
		bubble($$self, event);
	}

	function animationend_handler(event) {
		bubble($$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.iconContainer = $$value;
			$$invalidate(2, refs);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.titleContainer = $$value;
			$$invalidate(2, refs);
		});
	}

	function div_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.textContainer = $$value;
			$$invalidate(2, refs);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.content = $$value;
			$$invalidate(2, refs);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.container = $$value;
			$$invalidate(2, refs);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.elem = $$value;
			$$invalidate(2, refs);
		});
	}

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate(3, type = $$props.type);
		if ("title" in $$props) $$invalidate(4, title = $$props.title);
		if ("titleTrusted" in $$props) $$invalidate(5, titleTrusted = $$props.titleTrusted);
		if ("text" in $$props) $$invalidate(6, text = $$props.text);
		if ("textTrusted" in $$props) $$invalidate(7, textTrusted = $$props.textTrusted);
		if ("styling" in $$props) $$invalidate(31, styling = $$props.styling);
		if ("icons" in $$props) $$invalidate(32, icons = $$props.icons);
		if ("mode" in $$props) $$invalidate(8, mode = $$props.mode);
		if ("addClass" in $$props) $$invalidate(9, addClass = $$props.addClass);
		if ("cornerClass" in $$props) $$invalidate(10, cornerClass = $$props.cornerClass);
		if ("autoOpen" in $$props) $$invalidate(33, autoOpen = $$props.autoOpen);
		if ("width" in $$props) $$invalidate(34, width = $$props.width);
		if ("minHeight" in $$props) $$invalidate(35, minHeight = $$props.minHeight);
		if ("maxTextHeight" in $$props) $$invalidate(36, maxTextHeight = $$props.maxTextHeight);
		if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
		if ("animation" in $$props) $$invalidate(11, animation = $$props.animation);
		if ("animateSpeed" in $$props) $$invalidate(12, animateSpeed = $$props.animateSpeed);
		if ("shadow" in $$props) $$invalidate(13, shadow = $$props.shadow);
		if ("hide" in $$props) $$invalidate(37, hide = $$props.hide);
		if ("delay" in $$props) $$invalidate(38, delay = $$props.delay);
		if ("mouseReset" in $$props) $$invalidate(39, mouseReset = $$props.mouseReset);
		if ("remove" in $$props) $$invalidate(40, remove = $$props.remove);
		if ("destroy" in $$props) $$invalidate(41, destroy = $$props.destroy);
		if ("stack" in $$props) $$invalidate(1, stack = $$props.stack);
		if ("modules" in $$props) $$invalidate(14, modules = $$props.modules);
		if ("open" in $$props) $$invalidate(43, open = $$props.open);
		if ("close" in $$props) $$invalidate(44, close = $$props.close);
		if ("animateIn" in $$props) $$invalidate(45, animateIn = $$props.animateIn);
		if ("animateOut" in $$props) $$invalidate(46, animateOut = $$props.animateOut);
	};

	let _styles;
	let _icons;
	let _widthStyle;
	let _minHeightStyle;
	let _maxTextHeightStyle;
	let _titleElement;
	let _textElement;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*styling*/ 1) {
			// Grab styles from the styling object or use the styles provided.
			$: _styles = typeof styling === "object"
			? styling
			: styleRegistry[styling];
		}

		if ($$self.$$.dirty[1] & /*icons*/ 2) {
			// Grab the icons from the icons object or use provided icons
			$: _icons = typeof icons === "object" ? icons : iconRegistry[icons];
		}

		if ($$self.$$.dirty[1] & /*width*/ 8) {
			$: $$invalidate(23, _widthStyle = typeof width === "string" ? "width: " + width + ";" : "");
		}

		if ($$self.$$.dirty[1] & /*minHeight*/ 16) {
			$: $$invalidate(24, _minHeightStyle = typeof minHeight === "string"
			? "min-height: " + minHeight + ";"
			: "");
		}

		if ($$self.$$.dirty[1] & /*maxTextHeight*/ 32) {
			$: $$invalidate(25, _maxTextHeightStyle = typeof maxTextHeight === "string"
			? "max-height: " + maxTextHeight + "; overflow-y: auto;"
			: "");
		}

		if ($$self.$$.dirty[0] & /*title*/ 16) {
			$: $$invalidate(26, _titleElement = title instanceof HTMLElement);
		}

		if ($$self.$$.dirty[0] & /*text*/ 64) {
			$: $$invalidate(27, _textElement = text instanceof HTMLElement);
		}

		if ($$self.$$.dirty[0] & /*_titleElement, refs, title*/ 67108884) {
			$: if (_titleElement && refs.titleContainer) {
				refs.titleContainer.appendChild(title);
			}
		}

		if ($$self.$$.dirty[0] & /*_textElement, refs, text*/ 134217796) {
			$: if (_textElement && refs.textContainer) {
				refs.textContainer.appendChild(text);
			}
		}

		if ($$self.$$.dirty[0] & /*stack*/ 2 | $$self.$$.dirty[2] & /*_oldStack*/ 1024) {
			$: if (_oldStack !== stack) {
				if (_oldStack) {
					// Remove the notice from the old stack.
					_oldStack._removeNotice(self);
				}

				if (stack) {
					// Add the notice to the stack.
					stack._addNotice(self);
				}

				$$invalidate(72, _oldStack = stack);
			}
		}
	};

	return [
		icon,
		stack,
		refs,
		type,
		title,
		titleTrusted,
		text,
		textTrusted,
		mode,
		addClass,
		cornerClass,
		animation,
		animateSpeed,
		shadow,
		modules,
		getStyle,
		getIcon,
		_timer,
		_animatingClass,
		_moveClass,
		_moduleClasses,
		_masking,
		_maskingIn,
		_widthStyle,
		_minHeightStyle,
		_maxTextHeightStyle,
		_titleElement,
		_textElement,
		self,
		handleInteraction,
		handleLeaveInteraction,
		styling,
		icons,
		autoOpen,
		width,
		minHeight,
		maxTextHeight,
		hide,
		delay,
		mouseReset,
		remove,
		destroy,
		getState,
		open,
		close,
		animateIn,
		animateOut,
		cancelClose,
		queueClose,
		_preventTimerClose,
		fire,
		addModuleClass,
		removeModuleClass,
		hasModuleClass,
		getModuleIsNoticeOpen,
		setModuleIsNoticeOpen,
		setAnimating,
		getAnimatingClass,
		setAnimatingClass,
		_getMoveClass,
		_setMoveClass,
		_setMasking,
		_state,
		_animInTimer,
		_animOutTimer,
		_animating,
		_timerHide,
		_moduleIsNoticeOpen,
		_maskingTimer,
		_updatingIcon,
		_oldHide,
		_oldIcon,
		_oldStack,
		_styles,
		_icons,
		dispatch,
		dispatchLifecycleEvent,
		insertIntoDOM,
		removeFromDOM,
		mouseover_handler,
		transitionend_handler,
		pnotify_init_handler,
		pnotify_mount_handler,
		pnotify_update_handler,
		pnotify_beforeOpen_handler,
		pnotify_afterOpen_handler,
		pnotify_beforeClose_handler,
		pnotify_afterClose_handler,
		pnotify_beforeDestroy_handler,
		pnotify_afterDestroy_handler,
		mouseout_handler,
		mouseenter_handler,
		mouseleave_handler,
		mousemove_handler,
		mousedown_handler,
		mouseup_handler,
		click_handler,
		dblclick_handler,
		focus_handler,
		blur_handler,
		focusin_handler,
		focusout_handler,
		touchstart_handler,
		touchmove_handler,
		touchend_handler,
		touchcancel_handler,
		animationend_handler,
		div_binding,
		div_binding_1,
		div_binding_2,
		div0_binding,
		div1_binding,
		div2_binding
	];
}

class PNotifyCoreComponent extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				type: 3,
				title: 4,
				titleTrusted: 5,
				text: 6,
				textTrusted: 7,
				styling: 31,
				icons: 32,
				mode: 8,
				addClass: 9,
				cornerClass: 10,
				autoOpen: 33,
				width: 34,
				minHeight: 35,
				maxTextHeight: 36,
				icon: 0,
				animation: 11,
				animateSpeed: 12,
				shadow: 13,
				hide: 37,
				delay: 38,
				mouseReset: 39,
				remove: 40,
				destroy: 41,
				stack: 1,
				modules: 14,
				refs: 2,
				getState: 42,
				getStyle: 15,
				getIcon: 16,
				open: 43,
				close: 44,
				animateIn: 45,
				animateOut: 46,
				cancelClose: 47,
				queueClose: 48,
				_preventTimerClose: 49,
				fire: 50,
				addModuleClass: 51,
				removeModuleClass: 52,
				hasModuleClass: 53,
				getModuleIsNoticeOpen: 54,
				setModuleIsNoticeOpen: 55,
				setAnimating: 56,
				getAnimatingClass: 57,
				setAnimatingClass: 58,
				_getMoveClass: 59,
				_setMoveClass: 60,
				_setMasking: 61
			},
			[-1, -1, -1, -1]
		);
	}

	get type() {
		return this.$$.ctx[3];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get title() {
		return this.$$.ctx[4];
	}

	set title(title) {
		this.$set({ title });
		flush();
	}

	get titleTrusted() {
		return this.$$.ctx[5];
	}

	set titleTrusted(titleTrusted) {
		this.$set({ titleTrusted });
		flush();
	}

	get text() {
		return this.$$.ctx[6];
	}

	set text(text) {
		this.$set({ text });
		flush();
	}

	get textTrusted() {
		return this.$$.ctx[7];
	}

	set textTrusted(textTrusted) {
		this.$set({ textTrusted });
		flush();
	}

	get styling() {
		return this.$$.ctx[31];
	}

	set styling(styling) {
		this.$set({ styling });
		flush();
	}

	get icons() {
		return this.$$.ctx[32];
	}

	set icons(icons) {
		this.$set({ icons });
		flush();
	}

	get mode() {
		return this.$$.ctx[8];
	}

	set mode(mode) {
		this.$set({ mode });
		flush();
	}

	get addClass() {
		return this.$$.ctx[9];
	}

	set addClass(addClass) {
		this.$set({ addClass });
		flush();
	}

	get cornerClass() {
		return this.$$.ctx[10];
	}

	set cornerClass(cornerClass) {
		this.$set({ cornerClass });
		flush();
	}

	get autoOpen() {
		return this.$$.ctx[33];
	}

	set autoOpen(autoOpen) {
		this.$set({ autoOpen });
		flush();
	}

	get width() {
		return this.$$.ctx[34];
	}

	set width(width) {
		this.$set({ width });
		flush();
	}

	get minHeight() {
		return this.$$.ctx[35];
	}

	set minHeight(minHeight) {
		this.$set({ minHeight });
		flush();
	}

	get maxTextHeight() {
		return this.$$.ctx[36];
	}

	set maxTextHeight(maxTextHeight) {
		this.$set({ maxTextHeight });
		flush();
	}

	get icon() {
		return this.$$.ctx[0];
	}

	set icon(icon) {
		this.$set({ icon });
		flush();
	}

	get animation() {
		return this.$$.ctx[11];
	}

	set animation(animation) {
		this.$set({ animation });
		flush();
	}

	get animateSpeed() {
		return this.$$.ctx[12];
	}

	set animateSpeed(animateSpeed) {
		this.$set({ animateSpeed });
		flush();
	}

	get shadow() {
		return this.$$.ctx[13];
	}

	set shadow(shadow) {
		this.$set({ shadow });
		flush();
	}

	get hide() {
		return this.$$.ctx[37];
	}

	set hide(hide) {
		this.$set({ hide });
		flush();
	}

	get delay() {
		return this.$$.ctx[38];
	}

	set delay(delay) {
		this.$set({ delay });
		flush();
	}

	get mouseReset() {
		return this.$$.ctx[39];
	}

	set mouseReset(mouseReset) {
		this.$set({ mouseReset });
		flush();
	}

	get remove() {
		return this.$$.ctx[40];
	}

	set remove(remove) {
		this.$set({ remove });
		flush();
	}

	get destroy() {
		return this.$$.ctx[41];
	}

	set destroy(destroy) {
		this.$set({ destroy });
		flush();
	}

	get stack() {
		return this.$$.ctx[1];
	}

	set stack(stack) {
		this.$set({ stack });
		flush();
	}

	get modules() {
		return this.$$.ctx[14];
	}

	set modules(modules) {
		this.$set({ modules });
		flush();
	}

	get refs() {
		return this.$$.ctx[2];
	}

	get getState() {
		return this.$$.ctx[42];
	}

	get getStyle() {
		return this.$$.ctx[15];
	}

	get getIcon() {
		return this.$$.ctx[16];
	}

	get open() {
		return this.$$.ctx[43];
	}

	set open(open) {
		this.$set({ open });
		flush();
	}

	get close() {
		return this.$$.ctx[44];
	}

	set close(close) {
		this.$set({ close });
		flush();
	}

	get animateIn() {
		return this.$$.ctx[45];
	}

	set animateIn(animateIn) {
		this.$set({ animateIn });
		flush();
	}

	get animateOut() {
		return this.$$.ctx[46];
	}

	set animateOut(animateOut) {
		this.$set({ animateOut });
		flush();
	}

	get cancelClose() {
		return this.$$.ctx[47];
	}

	get queueClose() {
		return this.$$.ctx[48];
	}

	get _preventTimerClose() {
		return this.$$.ctx[49];
	}

	get fire() {
		return this.$$.ctx[50];
	}

	get addModuleClass() {
		return this.$$.ctx[51];
	}

	get removeModuleClass() {
		return this.$$.ctx[52];
	}

	get hasModuleClass() {
		return this.$$.ctx[53];
	}

	get getModuleIsNoticeOpen() {
		return this.$$.ctx[54];
	}

	get setModuleIsNoticeOpen() {
		return this.$$.ctx[55];
	}

	get setAnimating() {
		return this.$$.ctx[56];
	}

	get getAnimatingClass() {
		return this.$$.ctx[57];
	}

	get setAnimatingClass() {
		return this.$$.ctx[58];
	}

	get _getMoveClass() {
		return this.$$.ctx[59];
	}

	get _setMoveClass() {
		return this.$$.ctx[60];
	}

	get _setMasking() {
		return this.$$.ctx[61];
	}
}

export default PNotifyCoreComponent;

export {
	defaultStack,
	defaults,
	moduleRegistry as modules,
	modulesPrependContainer,
	modulesAppendContainer,
	modulesPrependContent,
	modulesAppendContent,
	styleRegistry as styles,
	iconRegistry as icons
};
//# sourceMappingURL=PNotifyCoreComponent.js.map