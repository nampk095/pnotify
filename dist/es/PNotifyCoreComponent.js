/* src/PNotifyCoreComponent.html generated by Svelte v3.18.1 */
import {
	HtmlTag,
	SvelteComponent,
	append,
	assign,
	attr,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	flush,
	get_spread_object,
	get_spread_update,
	group_outros,
	init as init_1,
	insert,
	listen,
	mount_component,
	outro_and_destroy_block,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text as text_1,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

import Stack from "./Stack.js";
import { onMount, beforeUpdate, tick, createEventDispatcher } from "svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[110] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[110] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[110] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[110] = list[i];
	return child_ctx;
}

// (223:4) {#if self}
function create_if_block_10(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value_3 = modulesPrependContainer;
	const get_key = ctx => /*module*/ ctx[110].key;

	for (let i = 0; i < each_value_3.length; i += 1) {
		let child_ctx = get_each_context_3(ctx, each_value_3, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_3(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const each_value_3 = modulesPrependContainer;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_3, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_3, each_1_anchor, get_each_context_3);
			check_outros();
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (224:6) {#each modulesPrependContainer as module (module.key)}
function create_each_block_3(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ _notice: /*self*/ ctx[17] }, /*modules*/ ctx[2][/*module*/ ctx[110].key]];

	function init_handler(...args) {
		return /*init_handler*/ ctx[100](/*module*/ ctx[110], ...args);
	}

	var switch_value = /*module*/ ctx[110];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("init", init_handler);
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty[0] & /*self, modules*/ 131076)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 131072 && { _notice: /*self*/ ctx[17] },
					dirty[0] & /*modules*/ 4 && get_spread_object(/*modules*/ ctx[2][/*module*/ ctx[110].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[110])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("init", init_handler);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (228:4) {#if icon !== false}
function create_if_block_9(ctx) {
	let div;
	let span;
	let span_class_value;
	let div_class_value;

	return {
		c() {
			div = element("div");
			span = element("span");

			attr(span, "class", span_class_value = /*icon*/ ctx[0] === true
			? /*getIcon*/ ctx[16](/*type*/ ctx[4])
			: /*icon*/ ctx[0]);

			attr(div, "class", div_class_value = "ui-pnotify-icon " + /*getStyle*/ ctx[15]("icon"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			/*div_binding*/ ctx[101](div);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon, type*/ 17 && span_class_value !== (span_class_value = /*icon*/ ctx[0] === true
			? /*getIcon*/ ctx[16](/*type*/ ctx[4])
			: /*icon*/ ctx[0])) {
				attr(span, "class", span_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[101](null);
		}
	};
}

// (234:6) {#if self}
function create_if_block_8(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value_2 = modulesPrependContent;
	const get_key = ctx => /*module*/ ctx[110].key;

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const each_value_2 = modulesPrependContent;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
			check_outros();
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (235:8) {#each modulesPrependContent as module (module.key)}
function create_each_block_2(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ _notice: /*self*/ ctx[17] }, /*modules*/ ctx[2][/*module*/ ctx[110].key]];

	function init_handler_1(...args) {
		return /*init_handler_1*/ ctx[102](/*module*/ ctx[110], ...args);
	}

	var switch_value = /*module*/ ctx[110];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("init", init_handler_1);
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty[0] & /*self, modules*/ 131076)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 131072 && { _notice: /*self*/ ctx[17] },
					dirty[0] & /*modules*/ 4 && get_spread_object(/*modules*/ ctx[2][/*module*/ ctx[110].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[110])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("init", init_handler_1);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (239:6) {#if title !== false}
function create_if_block_5(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_titleElement*/ ctx[26] && create_if_block_6(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "ui-pnotify-title " + /*getStyle*/ ctx[15]("title"));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_1*/ ctx[103](div);
		},
		p(ctx, dirty) {
			if (!/*_titleElement*/ ctx[26]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_1*/ ctx[103](null);
		}
	};
}

// (241:10) {#if !_titleElement}
function create_if_block_6(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*titleTrusted*/ ctx[6]) return create_if_block_7;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (244:12) {:else}
function create_else_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*title*/ ctx[5]);
			attr(span, "class", "ui-pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 32) set_data(t, /*title*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (242:12) {#if titleTrusted}
function create_if_block_7(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*title*/ ctx[5], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 32) html_tag.p(/*title*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (250:6) {#if text !== false}
function create_if_block_2(ctx) {
	let div;
	let div_class_value;
	let if_block = !/*_textElement*/ ctx[27] && create_if_block_3(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", div_class_value = "ui-pnotify-text " + /*getStyle*/ ctx[15]("text"));
			attr(div, "role", "alert");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_2*/ ctx[104](div);
		},
		p(ctx, dirty) {
			if (!/*_textElement*/ ctx[27]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			/*div_binding_2*/ ctx[104](null);
		}
	};
}

// (252:10) {#if !_textElement}
function create_if_block_3(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*textTrusted*/ ctx[8]) return create_if_block_4;
		return create_else_block;
	}

	let current_block_type = select_block_type_1(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (255:12) {:else}
function create_else_block(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text_1(/*text*/ ctx[7]);
			attr(span, "class", "ui-pnotify-pre-line");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 128) set_data(t, /*text*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (253:12) {#if textTrusted}
function create_if_block_4(ctx) {
	let html_tag;

	return {
		c() {
			html_tag = new HtmlTag(/*text*/ ctx[7], null);
		},
		m(target, anchor) {
			html_tag.m(target, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 128) html_tag.p(/*text*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) html_tag.d();
		}
	};
}

// (261:6) {#if self}
function create_if_block_1(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value_1 = modulesAppendContent;
	const get_key = ctx => /*module*/ ctx[110].key;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const each_value_1 = modulesAppendContent;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
			check_outros();
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (262:8) {#each modulesAppendContent as module (module.key)}
function create_each_block_1(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ _notice: /*self*/ ctx[17] }, /*modules*/ ctx[2][/*module*/ ctx[110].key]];

	function init_handler_2(...args) {
		return /*init_handler_2*/ ctx[105](/*module*/ ctx[110], ...args);
	}

	var switch_value = /*module*/ ctx[110];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("init", init_handler_2);
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty[0] & /*self, modules*/ 131076)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 131072 && { _notice: /*self*/ ctx[17] },
					dirty[0] & /*modules*/ 4 && get_spread_object(/*modules*/ ctx[2][/*module*/ ctx[110].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[110])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("init", init_handler_2);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (267:4) {#if self}
function create_if_block(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = modulesAppendContainer;
	const get_key = ctx => /*module*/ ctx[110].key;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const each_value = modulesAppendContainer;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			check_outros();
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
		}
	};
}

// (268:6) {#each modulesAppendContainer as module (module.key)}
function create_each_block(key_1, ctx) {
	let first;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ _notice: /*self*/ ctx[17] }, /*modules*/ ctx[2][/*module*/ ctx[110].key]];

	function init_handler_3(...args) {
		return /*init_handler_3*/ ctx[107](/*module*/ ctx[110], ...args);
	}

	var switch_value = /*module*/ ctx[110];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
		switch_instance.$on("init", init_handler_3);
	}

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			const switch_instance_changes = (dirty[0] & /*self, modules*/ 131076)
			? get_spread_update(switch_instance_spread_levels, [
					dirty[0] & /*self*/ 131072 && { _notice: /*self*/ ctx[17] },
					dirty[0] & /*modules*/ 4 && get_spread_object(/*modules*/ ctx[2][/*module*/ ctx[110].key])
				])
			: {};

			if (switch_value !== (switch_value = /*module*/ ctx[110])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					switch_instance.$on("init", init_handler_3);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div1;
	let t0;
	let t1;
	let div0;
	let t2;
	let t3;
	let t4;
	let div0_class_value;
	let t5;
	let div1_class_value;
	let div1_style_value;
	let div2_class_value;
	let current;
	let dispose;
	let if_block0 = /*self*/ ctx[17] && create_if_block_10(ctx);
	let if_block1 = /*icon*/ ctx[0] !== false && create_if_block_9(ctx);
	let if_block2 = /*self*/ ctx[17] && create_if_block_8(ctx);
	let if_block3 = /*title*/ ctx[5] !== false && create_if_block_5(ctx);
	let if_block4 = /*text*/ ctx[7] !== false && create_if_block_2(ctx);
	let if_block5 = /*self*/ ctx[17] && create_if_block_1(ctx);
	let if_block6 = /*self*/ ctx[17] && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			div0 = element("div");
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			t3 = space();
			if (if_block4) if_block4.c();
			t4 = space();
			if (if_block5) if_block5.c();
			t5 = space();
			if (if_block6) if_block6.c();
			attr(div0, "class", div0_class_value = "ui-pnotify-content " + /*getStyle*/ ctx[15]("content"));
			attr(div1, "class", div1_class_value = "\n        ui-pnotify-container\n        " + /*getStyle*/ ctx[15]("container") + "\n        " + /*getStyle*/ ctx[15](/*type*/ ctx[4]) + "\n        " + /*cornerClass*/ ctx[11] + "\n        " + (/*shadow*/ ctx[14] ? "ui-pnotify-shadow" : "") + "\n        " + /*_moduleClasses*/ ctx[21].container.join(" ") + "\n      ");
			attr(div1, "style", div1_style_value = "" + (/*_widthStyle*/ ctx[24] + " " + /*_minHeightStyle*/ ctx[25]));
			attr(div1, "role", "alert");
			attr(div2, "aria-live", "assertive");
			attr(div2, "role", "alertdialog");
			attr(div2, "ui-pnotify", "");

			attr(div2, "class", div2_class_value = "\n      ui-pnotify\n      " + (/*icon*/ ctx[0] !== false ? "ui-pnotify-with-icon" : "") + "\n      " + /*getStyle*/ ctx[15]("element") + "\n      ui-pnotify-mode-" + /*mode*/ ctx[9] + "\n      " + /*addClass*/ ctx[10] + "\n      " + /*_animatingClass*/ ctx[19] + "\n      " + /*_moveClass*/ ctx[20] + "\n      " + (/*animation*/ ctx[12] === "fade"
			? "ui-pnotify-fade-" + /*animateSpeed*/ ctx[13]
			: "") + "\n      " + (/*stack*/ ctx[1] && (/*stack*/ ctx[1].modal === true || /*stack*/ ctx[1].modal === "ish" && /*_timer*/ ctx[18] === "prevented")
			? "ui-pnotify-modal"
			: "") + "\n      " + (/*_masking*/ ctx[22]
			? "ui-pnotify-masking ui-pnotify-masking-" + /*_masking*/ ctx[22]
			: "") + "\n      " + (/*_maskingIn*/ ctx[23] ? "ui-pnotify-masking-in" : "") + "\n      " + /*_moduleClasses*/ ctx[21].elem.join(" ") + "\n    ");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t1);
			append(div1, div0);
			if (if_block2) if_block2.m(div0, null);
			append(div0, t2);
			if (if_block3) if_block3.m(div0, null);
			append(div0, t3);
			if (if_block4) if_block4.m(div0, null);
			append(div0, t4);
			if (if_block5) if_block5.m(div0, null);
			/*div0_binding*/ ctx[106](div0);
			append(div1, t5);
			if (if_block6) if_block6.m(div1, null);
			/*div1_binding*/ ctx[108](div1);
			/*div2_binding*/ ctx[109](div2);
			current = true;

			dispose = [
				listen(div2, "mouseenter", /*handleInteraction*/ ctx[28]),
				listen(div2, "mouseleave", /*handleLeaveInteraction*/ ctx[29]),
				listen(div2, "focusin", /*handleInteraction*/ ctx[28]),
				listen(div2, "focusout", /*handleLeaveInteraction*/ ctx[29]),
				listen(div2, "mouseover", /*mouseover_handler*/ ctx[83]),
				listen(div2, "mouseout", /*mouseout_handler*/ ctx[84]),
				listen(div2, "mouseenter", /*mouseenter_handler*/ ctx[85]),
				listen(div2, "mouseleave", /*mouseleave_handler*/ ctx[86]),
				listen(div2, "mousemove", /*mousemove_handler*/ ctx[87]),
				listen(div2, "mousedown", /*mousedown_handler*/ ctx[81]),
				listen(div2, "mouseup", /*mouseup_handler*/ ctx[88]),
				listen(div2, "click", /*click_handler*/ ctx[89]),
				listen(div2, "dblclick", /*dblclick_handler*/ ctx[90]),
				listen(div2, "focus", /*focus_handler*/ ctx[91]),
				listen(div2, "blur", /*blur_handler*/ ctx[92]),
				listen(div2, "focusin", /*focusin_handler*/ ctx[93]),
				listen(div2, "focusout", /*focusout_handler*/ ctx[94]),
				listen(div2, "touchstart", /*touchstart_handler*/ ctx[95]),
				listen(div2, "touchmove", /*touchmove_handler*/ ctx[96]),
				listen(div2, "touchend", /*touchend_handler*/ ctx[97]),
				listen(div2, "touchcancel", /*touchcancel_handler*/ ctx[98]),
				listen(div2, "animationend", /*animationend_handler*/ ctx[99]),
				listen(div2, "transitionend", /*transitionend_handler*/ ctx[82])
			];
		},
		p(ctx, dirty) {
			if (/*self*/ ctx[17]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*icon*/ ctx[0] !== false) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9(ctx);
					if_block1.c();
					if_block1.m(div1, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*self*/ ctx[17]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block_8(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div0, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[5] !== false) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_5(ctx);
					if_block3.c();
					if_block3.m(div0, t3);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (/*text*/ ctx[7] !== false) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_2(ctx);
					if_block4.c();
					if_block4.m(div0, t4);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (/*self*/ ctx[17]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);
					transition_in(if_block5, 1);
				} else {
					if_block5 = create_if_block_1(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div0, null);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*self*/ ctx[17]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);
					transition_in(if_block6, 1);
				} else {
					if_block6 = create_if_block(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div1, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*type, cornerClass, shadow, _moduleClasses*/ 2115600 && div1_class_value !== (div1_class_value = "\n        ui-pnotify-container\n        " + /*getStyle*/ ctx[15]("container") + "\n        " + /*getStyle*/ ctx[15](/*type*/ ctx[4]) + "\n        " + /*cornerClass*/ ctx[11] + "\n        " + (/*shadow*/ ctx[14] ? "ui-pnotify-shadow" : "") + "\n        " + /*_moduleClasses*/ ctx[21].container.join(" ") + "\n      ")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*_widthStyle, _minHeightStyle*/ 50331648 && div1_style_value !== (div1_style_value = "" + (/*_widthStyle*/ ctx[24] + " " + /*_minHeightStyle*/ ctx[25]))) {
				attr(div1, "style", div1_style_value);
			}

			if (!current || dirty[0] & /*icon, mode, addClass, _animatingClass, _moveClass, animation, animateSpeed, stack, _timer, _masking, _maskingIn, _moduleClasses*/ 16528899 && div2_class_value !== (div2_class_value = "\n      ui-pnotify\n      " + (/*icon*/ ctx[0] !== false ? "ui-pnotify-with-icon" : "") + "\n      " + /*getStyle*/ ctx[15]("element") + "\n      ui-pnotify-mode-" + /*mode*/ ctx[9] + "\n      " + /*addClass*/ ctx[10] + "\n      " + /*_animatingClass*/ ctx[19] + "\n      " + /*_moveClass*/ ctx[20] + "\n      " + (/*animation*/ ctx[12] === "fade"
			? "ui-pnotify-fade-" + /*animateSpeed*/ ctx[13]
			: "") + "\n      " + (/*stack*/ ctx[1] && (/*stack*/ ctx[1].modal === true || /*stack*/ ctx[1].modal === "ish" && /*_timer*/ ctx[18] === "prevented")
			? "ui-pnotify-modal"
			: "") + "\n      " + (/*_masking*/ ctx[22]
			? "ui-pnotify-masking ui-pnotify-masking-" + /*_masking*/ ctx[22]
			: "") + "\n      " + (/*_maskingIn*/ ctx[23] ? "ui-pnotify-masking-in" : "") + "\n      " + /*_moduleClasses*/ ctx[21].elem.join(" ") + "\n    ")) {
				attr(div2, "class", div2_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block2);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block2);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			/*div0_binding*/ ctx[106](null);
			if (if_block6) if_block6.d();
			/*div1_binding*/ ctx[108](null);
			/*div2_binding*/ ctx[109](null);
			run_all(dispose);
		}
	};
}

let posTimer;

// These actions need to be done once the DOM is ready.
function onDocumentLoaded() {
	defaultStack.context = document.body;

	// Reposition the notices when the window resizes.
	window.addEventListener("resize", () => {
		// This timer is used for queueing the position event so it doesn't run
		// repeatedly.
		if (posTimer) {
			clearTimeout(posTimer);
		}

		posTimer = setTimeout(
			() => {
				var event = new Event("pnotify:position");
				document.body.dispatchEvent(event);
				posTimer = null;
			},
			10
		);
	});
}

const defaultStack = new Stack({
		dir1: "down",
		dir2: "left",
		firstpos1: 25,
		firstpos2: 25,
		spacing1: 36,
		spacing2: 36,
		push: "bottom"
	});

const defaults = {
	// Type of the notice. 'notice', 'info', 'success', or 'error'.
	type: "notice",
	// The notice's title. Can be a string, an element, or `false` for no title.
	title: false,
	// Whether to trust the title or escape its contents. (Not allow HTML.)
	titleTrusted: false,
	// The notice's text. Can be a string, an element, or `false` for no text.
	text: false,
	// Whether to trust the text or escape its contents. (Not allow HTML.)
	textTrusted: false,
	// What styling classes to use. (Can be 'brighttheme', 'material',
	// 'bootstrap3', 'bootstrap4', or a styling object.)
	styling: "brighttheme",
	// What icons to use (Can be 'brighttheme', 'material', 'bootstrap3',
	// 'fontawesome4', 'fontawesome5', or an icon object.)
	icons: "brighttheme",
	// Light or dark version of the theme, if supported by the styling. This
	// overrides the CSS media query when a preference is given. (Can be
	// 'no-preference', 'light', or 'dark'.)
	mode: "no-preference",
	// Additional classes to be added to the notice. (For custom styling.)
	addClass: "",
	// Class to be added to the notice for corner styling.
	cornerClass: "",
	// Display the notice immediately when it is created.
	autoOpen: true,
	// Width of the notice.
	width: "360px",
	// Minimum height of the notice. It will expand to fit content.
	minHeight: "16px",
	// Set icon to true to use the default icon for the selected
	// style/type, false for no icon, or a string for your own icon class.
	icon: true,
	// The animation to use when displaying and hiding the notice. 'none'
	// and 'fade' are supported through CSS. Others are supported
	// through the Animate module and Animate.css.
	animation: "fade",
	// Speed at which the notice animates in and out. 'slow', 'normal',
	// or 'fast'. Respectively, 400ms, 250ms, 100ms.
	animateSpeed: "normal",
	// Display a drop shadow.
	shadow: true,
	// After a delay, remove the notice.
	hide: true,
	// Delay in milliseconds before the notice is removed.
	delay: 8000,
	// Reset the hide timer if the mouse moves over the notice.
	mouseReset: true,
	// Remove the notice's elements from the DOM after it is removed.
	remove: true,
	// Whether to remove the notice from the stack array (and therefore,
	// history) when it is closed.
	destroy: true,
	// The stack on which the notices will be placed. Also controls the
	// direction the notices stack.
	stack: defaultStack,
	// This is where options for modules should be defined.
	modules: {}
};

// This object holds all the PNotify modules. They are used to provide
// additional functionality.
const moduleRegistry = {};

const modulesPrependContainer = [];
const modulesAppendContainer = [];
const modulesPrependContent = [];
const modulesAppendContent = [];

const styleRegistry = {
	bootstrap3: {
		container: "alert",
		notice: "alert-warning",
		info: "alert-info",
		success: "alert-success",
		error: "alert-danger"
	},
	bootstrap4: {
		container: "alert",
		notice: "alert-warning",
		info: "alert-info",
		success: "alert-success",
		error: "alert-danger"
	}
};

// icons are separate from the style, since bs4 doesn't come with any
const iconRegistry = {
	bootstrap3: {
		notice: "glyphicon glyphicon-exclamation-sign",
		info: "glyphicon glyphicon-info-sign",
		success: "glyphicon glyphicon-ok-sign",
		error: "glyphicon glyphicon-warning-sign"
	},
	// User must have Font Awesome v4.0+
	fontawesome4: {
		notice: "fa fa-exclamation-circle",
		info: "fa fa-info-circle",
		success: "fa fa-check-circle",
		error: "fa fa-exclamation-triangle"
	},
	// User must have Font Awesome v5.0+
	fontawesome5: {
		notice: "fas fa-exclamation-circle",
		info: "fas fa-info-circle",
		success: "fas fa-check-circle",
		error: "fas fa-exclamation-triangle"
	}
};

// Run the deferred actions once the DOM is ready.
if (window && document.body) {
	onDocumentLoaded();
} else {
	document.addEventListener("DOMContentLoaded", onDocumentLoaded);
}

function instance($$self, $$props, $$invalidate) {
	let self;
	const dispatch = createEventDispatcher();
	let { type = defaults.type } = $$props;
	let { title = defaults.title } = $$props;
	let { titleTrusted = defaults.titleTrusted } = $$props;
	let { text = defaults.text } = $$props;
	let { textTrusted = defaults.textTrusted } = $$props;
	let { styling = defaults.styling } = $$props;
	let { icons = defaults.icons } = $$props;
	let { mode = defaults.mode } = $$props;
	let { addClass = defaults.addClass } = $$props;
	let { cornerClass = defaults.cornerClass } = $$props;
	let { autoOpen = defaults.autoOpen } = $$props;
	let { width = defaults.width } = $$props;
	let { minHeight = defaults.minHeight } = $$props;
	let { icon = defaults.icon } = $$props;
	let { animation = defaults.animation } = $$props;
	let { animateSpeed = defaults.animateSpeed } = $$props;
	let { shadow = defaults.shadow } = $$props;
	let { hide = defaults.hide } = $$props;
	let { delay = defaults.delay } = $$props;
	let { mouseReset = defaults.mouseReset } = $$props;
	let { remove = defaults.remove } = $$props;
	let { destroy = defaults.destroy } = $$props;
	let { stack = defaults.stack } = $$props;
	let { modules = Object.assign({}, defaults.modules) } = $$props;

	const refs = {
		elem: null,
		container: null,
		content: null,
		iconContainer: null,
		titleContainer: null,
		textContainer: null
	};

	// The state can be 'initializing', 'waiting', 'opening', 'open', 'closing',
	// or 'closed'.
	let _state = "initializing";

	// Auto close timer.
	let _timer = null;

	// Animation timers.
	let _animInTimer = null;

	let _animOutTimer = null;

	// Stores what is currently being animated (in or out).
	let _animating = false;

	// Stores the class that adds entry/exit animation effects.
	let _animatingClass = "";

	// Stores the class that adds movement animation effects.
	let _moveClass = "";

	// Stores whether the notice was hidden by a timer.
	let _timerHide = false;

	// Stores the accessors of the modules.
	let _moduleAccessors = {};

	// Holds classes that modules add for the notice element or container element.
	let _moduleClasses = { elem: [], container: [] };

	// Modules that change how the notice displays (causing the notice element to
	// not appear) can set this to true to make PNotify assume the notice has
	// opened.
	let _moduleIsNoticeOpen = false;

	// The masking control for the second notice in a modalish stack when the
	// first notice is hovered.
	let _masking = false;

	let _maskingIn = false;
	let _maskingTimer = null;

	// These hold the instances to the Svelte-loaded modules.
	// const _modulesPrependContainerInstances = [];
	// const _modulesAppendContainerInstances = [];
	// This keeps the beforeUpdate handler from going into a loop when we're
	// taming Font Awesome's magic.
	let _updatingIcon = false;

	// Save the old value of hide and icon, so we can do our magic.
	let _oldHide = hide;

	let _oldIcon = icon;
	const getState = () => _state;

	const getStyle = name => _styles && name in _styles
	? _styles[name]
	: styling + "-" + name;

	const getIcon = name => _icons && name in _icons
	? _icons[name]
	: icons + "-icon-" + name;

	beforeUpdate(async () => {
		if (_updatingIcon) {
			return;
		}

		runModules("update");

		// Update the timed hiding.
		if (_state !== "closed" && _state !== "waiting" && hide !== _oldHide) {
			if (!hide) {
				cancelClose();
			} else if (!_oldHide) {
				queueClose();
			}
		}

		// Queue a position
		if (_state !== "closed" && _state !== "closing" && stack && !stack._collapsingModalState) {
			stack.queuePosition();
		}

		// Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
		// In order to make it play nice with Svelte, we have to clear the element
		// and make it again.
		if (icon !== _oldIcon && (icon === true && icons === "fontawesome5" || typeof icon === "string" && icon.match(/(^| )fa[srlb]($| )/))) {
			const newIcon = icon;
			$$invalidate(0, icon = false);
			_updatingIcon = true;
			await tick();
			$$invalidate(0, icon = newIcon);
			_updatingIcon = false;
		}

		// Save old options.
		_oldHide = hide;

		_oldIcon = icon;
	});

	function handleInteraction(e) {
		// Stop animation, reset the removal timer when the user interacts.
		if (mouseReset && _state === "closing") {
			if (!_timerHide) {
				return;
			}

			cancelClose();
		}

		// Stop the close timer.
		if (hide && mouseReset) {
			cancelClose();
		}
	}

	function handleLeaveInteraction(e) {
		// Start the close timer.
		if (hide && mouseReset && _animating !== "out") {
			queueClose();
		}
	}

	async function init(notice) {
		// Init is passed the instance, since Svelte does not give access to it.
		$$invalidate(17, self = notice);

		if (stack) {
			// Add the notice to the notice array.
			stack._addNotice(self);
		}

		// Wait for self to propagate to modules.
		await tick();

		runModules("init");

		// We're now initialized, but haven't been opened yet.
		_state = "closed";

		// Display the notice.
		if (autoOpen) {
			open();
		}
	}

	// This runs an event on all the modules.
	function runModules(event) {
		if (event === "init") {
			// Initializing a module should only be done if it has an init
			// function, which means it's not rendered in the template.
			for (let key in _moduleAccessors) {
				if (!_moduleAccessors.hasOwnProperty(key)) {
					continue;
				}

				initModule(key, _moduleAccessors[key]);
			}

			for (let key in moduleRegistry) {
				if (!moduleRegistry.hasOwnProperty(key)) {
					continue;
				}

				if ("factory" in moduleRegistry[key]) {
					const moduleOptions = Object.assign({ _notice: self }, modules[key]);
					_moduleAccessors[key] = moduleRegistry[key].factory(self, moduleOptions);
					initModule(key, _moduleAccessors[key]);
				}
			}
		} else {
			for (let key in _moduleAccessors) {
				if (!_moduleAccessors.hasOwnProperty(key)) {
					continue;
				}

				if (event === "update") {
					if ("$set" in _moduleAccessors[key]) {
						const moduleOptions = Object.assign({ _notice: self }, modules[key]);
						_moduleAccessors[key].$set(moduleOptions);
					}
				} else {
					if (event in _moduleAccessors[key]) {
						_moduleAccessors[key][event]();
					}
				}
			}
		}
	}

	function saveAccessor(key, accessor) {
		_moduleAccessors[key] = accessor;
	}

	// This passes module options to a module.
	function initModule(key, accessor) {
		if (!modules.hasOwnProperty(key)) {
			$$invalidate(2, modules[key] = {}, modules);
		}

		if ("$set" in accessor) {
			const moduleOptions = Object.assign({ _notice: self }, modules[key]);
			accessor.$set(moduleOptions);
		}

		if ("init" in accessor) {
			accessor.init();
		}
	}

	function insertIntoDOM() {
		// If the notice is not in the DOM, or in the wrong context, append it.
		if (refs.elem && !refs.elem.parentNode || stack && stack.context && stack.context !== refs.elem.parentNode) {
			if (stack && (stack.context || document.body)) {
				if (!stack.context) {
					$$invalidate(1, stack.context = document.body, stack);
				}

				stack.context.appendChild(refs.elem);
			} else {
				throw new Error("No context to insert this notice into.");
			}
		}
	}

	function removeFromDOM() {
		refs.elem && refs.elem.parentNode.removeChild(refs.elem);
	}

	let { open = immediate => {
		if (_state === "opening") {
			return;
		}

		if (_state === "open") {
			if (hide) {
				queueClose();
			}

			return;
		}

		if (stack && stack._shouldNoticeWait()) {
			_state = "waiting";
			return;
		}

		_state = "opening";
		$$invalidate(22, _masking = false);

		// This makes the notice visibity: hidden; so its dimensions can be
		// determined.
		$$invalidate(19, _animatingClass = "ui-pnotify-initial-hidden");

		runModules("beforeOpen");

		const afterOpenCallback = () => {
			// Now set it to hide.
			if (hide) {
				queueClose();
			}

			_state = "open";
			runModules("afterOpen");
		};

		if (stack) {
			// Notify the stack that a notice has opened.
			stack._handleNoticeOpened(self);
		}

		if (_moduleIsNoticeOpen) {
			afterOpenCallback();
			return;
		}

		insertIntoDOM();

		// Wait until the DOM is updated.
		window.requestAnimationFrame(() => {
			if (_state !== "opening") {
				return;
			}

			if (stack) {
				// Mark the stack so it won't animate the new notice.
				$$invalidate(1, stack._animation = false, stack);

				if (stack.push === "top") {
					// Reset the position data so the notice is positioned as the first
					// notice.
					stack._resetPositionData();
				}

				// Now position the stack's the notices.
				stack._positionNotice(self);

				stack.queuePosition(0);

				// Reset animation.
				$$invalidate(1, stack._animation = true, stack);
			}

			animateIn(afterOpenCallback, immediate);
		});
	} } = $$props;

	let { close = (immediate, timerHide, waitAfterward) => {
		if (_state === "closing" || _state === "closed") {
			return;
		}

		const runDestroy = () => {
			runModules("beforeDestroy");

			if (stack) {
				stack._removeNotice(self);
			}

			self.$destroy();
			runModules("afterDestroy");
			runModules("$destroy");
		};

		if (_state === "waiting") {
			if (waitAfterward) {
				return;
			}

			_state = "closed";

			// It's debatable whether the notice should be destroyed in this case, but
			// I'm going to go ahead and say yes.
			if (destroy && !waitAfterward) {
				runDestroy();
			}

			return;
		}

		_state = "closing";
		_timerHide = !!timerHide; // Make sure it's a boolean.
		runModules("beforeClose");

		if (_timer && _timer !== "prevented" && clearTimeout) {
			clearTimeout(_timer);
		}

		$$invalidate(18, _timer = null);

		animateOut(
			() => {
				_timerHide = false;
				_state = waitAfterward ? "waiting" : "closed";
				runModules("afterClose");

				if (stack) {
					stack._handleNoticeClosed(self);
				}

				if (destroy && !waitAfterward) {
					// If we're supposed to destroy the notice, run the destroy module
					// events, remove from stack, and let Svelte handle DOM removal.
					runDestroy();
				} else if (remove && !waitAfterward) {
					// If we're supposed to remove the notice from the DOM, do it.
					removeFromDOM();
				}
			},
			immediate
		);
	} } = $$props;

	let { animateIn = async (callback, immediate) => {
		// Declare that the notice is animating in.
		_animating = "in";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animInTimer) {
				clearTimeout(_animInTimer);
			}

			if (_animating !== "in") {
				return;
			}

			let visible = _moduleIsNoticeOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (visible) {
				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				_animInTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(19, _animatingClass = "ui-pnotify-in");

			// eslint-disable-next-line no-unused-expressions
			refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.

			$$invalidate(19, _animatingClass = "ui-pnotify-in ui-pnotify-fade-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animInTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(19, _animatingClass = "ui-pnotify-in");
			await tick();
			finished();
		}
	} } = $$props;

	let { animateOut = async (callback, immediate) => {
		// Declare that the notice is animating out.
		_animating = "out";

		const finished = event => {
			if (event && refs.elem && event.target !== refs.elem) {
				return;
			}

			refs.elem && refs.elem.removeEventListener("transitionend", finished);

			if (_animOutTimer) {
				clearTimeout(_animOutTimer);
			}

			if (_animating !== "out") {
				return;
			}

			let visible = _moduleIsNoticeOpen;

			if (!visible && refs.elem) {
				const domRect = refs.elem.getBoundingClientRect();

				for (let prop in domRect) {
					if (domRect[prop] > 0) {
						visible = true;
						break;
					}
				}
			}

			if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === "0" || !visible) {
				$$invalidate(19, _animatingClass = "");

				if (callback) {
					callback.call();
				}

				// Declare that the notice has completed animating.
				_animating = false;
			} else {
				// In case this was called before the notice finished animating.
				_animOutTimer = setTimeout(finished, 40);
			}
		};

		if (animation === "fade" && !immediate) {
			refs.elem && refs.elem.addEventListener("transitionend", finished);
			$$invalidate(19, _animatingClass = "ui-pnotify-in");

			// Just in case the event doesn't fire, call it after 650 ms.
			_animOutTimer = setTimeout(finished, 650);
		} else {
			$$invalidate(19, _animatingClass = "");
			await tick();
			finished();
		}
	} } = $$props;

	function cancelClose() {
		if (_timer && _timer !== "prevented") {
			clearTimeout(_timer);
		}

		if (_animOutTimer) {
			clearTimeout(_animOutTimer);
		}

		if (_state === "closing") {
			// If it's animating out, stop it.
			_state = "open";

			_animating = false;

			$$invalidate(19, _animatingClass = animation === "fade"
			? "ui-pnotify-in ui-pnotify-fade-in"
			: "ui-pnotify-in");
		}
	}

	function queueClose() {
		if (_timer === "prevented") {
			return;
		}

		// Cancel any current close timer.
		cancelClose();

		$$invalidate(18, _timer = setTimeout(() => close(false, true), isNaN(delay) ? 0 : delay));
	}

	function _preventTimerClose(prevent) {
		if (prevent) {
			cancelClose();
			$$invalidate(18, _timer = "prevented");
		} else if (_timer === "prevented") {
			$$invalidate(18, _timer = null);

			if (_state === "open" && hide) {
				queueClose();
			}
		}
	}

	function fire(name, detail) {
		dispatch(name, detail);
	}

	function addModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				_moduleClasses[element].push(className);
			}
		}

		$$invalidate(21, _moduleClasses);
	}

	function removeModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];
			const idx = _moduleClasses[element].indexOf(className);

			if (idx !== -1) {
				_moduleClasses[element].splice(idx, 1);
			}
		}

		$$invalidate(21, _moduleClasses);
	}

	function hasModuleClass(element, ...classNames) {
		for (let i = 0; i < classNames.length; i++) {
			let className = classNames[i];

			if (_moduleClasses[element].indexOf(className) === -1) {
				return false;
			}
		}

		return true;
	}

	function getModuleAccessors() {
		return _moduleAccessors;
	}

	function getModuleIsNoticeOpen() {
		return _moduleIsNoticeOpen;
	}

	function setModuleIsNoticeOpen(value) {
		return _moduleIsNoticeOpen = value;
	}

	function setAnimating(value) {
		return _animating = value;
	}

	function getAnimatingClass() {
		return _animatingClass;
	}

	function setAnimatingClass(value) {
		return $$invalidate(19, _animatingClass = value);
	}

	function _getMoveClass() {
		return _moveClass;
	}

	function _setMoveClass(value) {
		return $$invalidate(20, _moveClass = value);
	}

	function _setMasking(value, immediate) {
		if (_maskingTimer) {
			clearTimeout(_maskingTimer);
		}

		if (value) {
			insertIntoDOM();
			$$invalidate(22, _masking = value);

			if (immediate) {
				$$invalidate(23, _maskingIn = true);
			} else {
				window.requestAnimationFrame(() => {
					if (_masking) {
						$$invalidate(23, _maskingIn = true);
					}
				});
			}
		} else if (immediate) {
			$$invalidate(22, _masking = false);
			$$invalidate(23, _maskingIn = false);

			if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
				removeFromDOM();
			}
		} else {
			const finished = () => {
				refs.elem && refs.elem.removeEventListener("transitionend", finished);

				if (_maskingTimer) {
					clearTimeout(_maskingTimer);
				}

				if (!_maskingIn) {
					$$invalidate(22, _masking = false);

					if (remove && ["open", "opening", "closing"].indexOf(_state) === -1) {
						removeFromDOM();
					}
				}
			};

			$$invalidate(23, _maskingIn = false);
			refs.elem && refs.elem.addEventListener("transitionend", finished);

			// eslint-disable-next-line no-unused-expressions
			refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.

			// Just in case the event doesn't fire, call it after 650 ms.
			_maskingTimer = setTimeout(finished, 650);
		}
	}

	function mousedown_handler(event) {
		bubble($$self, event);
	}

	function transitionend_handler(event) {
		bubble($$self, event);
	}

	function mouseover_handler(event) {
		bubble($$self, event);
	}

	function mouseout_handler(event) {
		bubble($$self, event);
	}

	function mouseenter_handler(event) {
		bubble($$self, event);
	}

	function mouseleave_handler(event) {
		bubble($$self, event);
	}

	function mousemove_handler(event) {
		bubble($$self, event);
	}

	function mouseup_handler(event) {
		bubble($$self, event);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	function dblclick_handler(event) {
		bubble($$self, event);
	}

	function focus_handler(event) {
		bubble($$self, event);
	}

	function blur_handler(event) {
		bubble($$self, event);
	}

	function focusin_handler(event) {
		bubble($$self, event);
	}

	function focusout_handler(event) {
		bubble($$self, event);
	}

	function touchstart_handler(event) {
		bubble($$self, event);
	}

	function touchmove_handler(event) {
		bubble($$self, event);
	}

	function touchend_handler(event) {
		bubble($$self, event);
	}

	function touchcancel_handler(event) {
		bubble($$self, event);
	}

	function animationend_handler(event) {
		bubble($$self, event);
	}

	const init_handler = (module, event) => saveAccessor(module.key, event.detail);

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.iconContainer = $$value;
			$$invalidate(3, refs);
		});
	}

	const init_handler_1 = (module, event) => saveAccessor(module.key, event.detail);

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.titleContainer = $$value;
			$$invalidate(3, refs);
		});
	}

	function div_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.textContainer = $$value;
			$$invalidate(3, refs);
		});
	}

	const init_handler_2 = (module, event) => saveAccessor(module.key, event.detail);

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.content = $$value;
			$$invalidate(3, refs);
		});
	}

	const init_handler_3 = (module, event) => saveAccessor(module.key, event.detail);

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.container = $$value;
			$$invalidate(3, refs);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			refs.elem = $$value;
			$$invalidate(3, refs);
		});
	}

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate(4, type = $$props.type);
		if ("title" in $$props) $$invalidate(5, title = $$props.title);
		if ("titleTrusted" in $$props) $$invalidate(6, titleTrusted = $$props.titleTrusted);
		if ("text" in $$props) $$invalidate(7, text = $$props.text);
		if ("textTrusted" in $$props) $$invalidate(8, textTrusted = $$props.textTrusted);
		if ("styling" in $$props) $$invalidate(31, styling = $$props.styling);
		if ("icons" in $$props) $$invalidate(32, icons = $$props.icons);
		if ("mode" in $$props) $$invalidate(9, mode = $$props.mode);
		if ("addClass" in $$props) $$invalidate(10, addClass = $$props.addClass);
		if ("cornerClass" in $$props) $$invalidate(11, cornerClass = $$props.cornerClass);
		if ("autoOpen" in $$props) $$invalidate(33, autoOpen = $$props.autoOpen);
		if ("width" in $$props) $$invalidate(34, width = $$props.width);
		if ("minHeight" in $$props) $$invalidate(35, minHeight = $$props.minHeight);
		if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
		if ("animation" in $$props) $$invalidate(12, animation = $$props.animation);
		if ("animateSpeed" in $$props) $$invalidate(13, animateSpeed = $$props.animateSpeed);
		if ("shadow" in $$props) $$invalidate(14, shadow = $$props.shadow);
		if ("hide" in $$props) $$invalidate(36, hide = $$props.hide);
		if ("delay" in $$props) $$invalidate(37, delay = $$props.delay);
		if ("mouseReset" in $$props) $$invalidate(38, mouseReset = $$props.mouseReset);
		if ("remove" in $$props) $$invalidate(39, remove = $$props.remove);
		if ("destroy" in $$props) $$invalidate(40, destroy = $$props.destroy);
		if ("stack" in $$props) $$invalidate(1, stack = $$props.stack);
		if ("modules" in $$props) $$invalidate(2, modules = $$props.modules);
		if ("open" in $$props) $$invalidate(43, open = $$props.open);
		if ("close" in $$props) $$invalidate(44, close = $$props.close);
		if ("animateIn" in $$props) $$invalidate(45, animateIn = $$props.animateIn);
		if ("animateOut" in $$props) $$invalidate(46, animateOut = $$props.animateOut);
	};

	let _styles;
	let _icons;
	let _widthStyle;
	let _minHeightStyle;
	let _titleElement;
	let _textElement;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*styling*/ 1) {
			// Grab styles from the styling object or use the styles provided.
			$: _styles = typeof styling === "object"
			? styling
			: styleRegistry[styling];
		}

		if ($$self.$$.dirty[1] & /*icons*/ 2) {
			// Grab the icons from the icons object or use provided icons
			$: _icons = typeof icons === "object" ? icons : iconRegistry[icons];
		}

		if ($$self.$$.dirty[1] & /*width*/ 8) {
			$: $$invalidate(24, _widthStyle = typeof width === "string" ? "width: " + width + ";" : "");
		}

		if ($$self.$$.dirty[1] & /*minHeight*/ 16) {
			$: $$invalidate(25, _minHeightStyle = typeof minHeight === "string"
			? "min-height: " + minHeight + ";"
			: "");
		}

		if ($$self.$$.dirty[0] & /*title*/ 32) {
			$: $$invalidate(26, _titleElement = title instanceof HTMLElement);
		}

		if ($$self.$$.dirty[0] & /*text*/ 128) {
			$: $$invalidate(27, _textElement = text instanceof HTMLElement);
		}

		if ($$self.$$.dirty[0] & /*_titleElement, refs, title*/ 67108904) {
			$: if (_titleElement && refs.titleContainer) {
				refs.titleContainer.appendChild(title);
			}
		}

		if ($$self.$$.dirty[0] & /*_textElement, refs, text*/ 134217864) {
			$: if (_textElement && refs.textContainer) {
				refs.textContainer.appendChild(text);
			}
		}
	};

	return [
		icon,
		stack,
		modules,
		refs,
		type,
		title,
		titleTrusted,
		text,
		textTrusted,
		mode,
		addClass,
		cornerClass,
		animation,
		animateSpeed,
		shadow,
		getStyle,
		getIcon,
		self,
		_timer,
		_animatingClass,
		_moveClass,
		_moduleClasses,
		_masking,
		_maskingIn,
		_widthStyle,
		_minHeightStyle,
		_titleElement,
		_textElement,
		handleInteraction,
		handleLeaveInteraction,
		saveAccessor,
		styling,
		icons,
		autoOpen,
		width,
		minHeight,
		hide,
		delay,
		mouseReset,
		remove,
		destroy,
		getState,
		init,
		open,
		close,
		animateIn,
		animateOut,
		cancelClose,
		queueClose,
		_preventTimerClose,
		fire,
		addModuleClass,
		removeModuleClass,
		hasModuleClass,
		getModuleAccessors,
		getModuleIsNoticeOpen,
		setModuleIsNoticeOpen,
		setAnimating,
		getAnimatingClass,
		setAnimatingClass,
		_getMoveClass,
		_setMoveClass,
		_setMasking,
		_state,
		_animInTimer,
		_animOutTimer,
		_animating,
		_timerHide,
		_moduleAccessors,
		_moduleIsNoticeOpen,
		_maskingTimer,
		_updatingIcon,
		_oldHide,
		_oldIcon,
		_styles,
		_icons,
		dispatch,
		runModules,
		initModule,
		insertIntoDOM,
		removeFromDOM,
		mousedown_handler,
		transitionend_handler,
		mouseover_handler,
		mouseout_handler,
		mouseenter_handler,
		mouseleave_handler,
		mousemove_handler,
		mouseup_handler,
		click_handler,
		dblclick_handler,
		focus_handler,
		blur_handler,
		focusin_handler,
		focusout_handler,
		touchstart_handler,
		touchmove_handler,
		touchend_handler,
		touchcancel_handler,
		animationend_handler,
		init_handler,
		div_binding,
		init_handler_1,
		div_binding_1,
		div_binding_2,
		init_handler_2,
		div0_binding,
		init_handler_3,
		div1_binding,
		div2_binding
	];
}

class PNotifyCoreComponent extends SvelteComponent {
	constructor(options) {
		super();

		init_1(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				type: 4,
				title: 5,
				titleTrusted: 6,
				text: 7,
				textTrusted: 8,
				styling: 31,
				icons: 32,
				mode: 9,
				addClass: 10,
				cornerClass: 11,
				autoOpen: 33,
				width: 34,
				minHeight: 35,
				icon: 0,
				animation: 12,
				animateSpeed: 13,
				shadow: 14,
				hide: 36,
				delay: 37,
				mouseReset: 38,
				remove: 39,
				destroy: 40,
				stack: 1,
				modules: 2,
				refs: 3,
				getState: 41,
				getStyle: 15,
				getIcon: 16,
				init: 42,
				open: 43,
				close: 44,
				animateIn: 45,
				animateOut: 46,
				cancelClose: 47,
				queueClose: 48,
				_preventTimerClose: 49,
				fire: 50,
				addModuleClass: 51,
				removeModuleClass: 52,
				hasModuleClass: 53,
				getModuleAccessors: 54,
				getModuleIsNoticeOpen: 55,
				setModuleIsNoticeOpen: 56,
				setAnimating: 57,
				getAnimatingClass: 58,
				setAnimatingClass: 59,
				_getMoveClass: 60,
				_setMoveClass: 61,
				_setMasking: 62
			},
			[-1, -1, -1, -1]
		);
	}

	get type() {
		return this.$$.ctx[4];
	}

	set type(type) {
		this.$set({ type });
		flush();
	}

	get title() {
		return this.$$.ctx[5];
	}

	set title(title) {
		this.$set({ title });
		flush();
	}

	get titleTrusted() {
		return this.$$.ctx[6];
	}

	set titleTrusted(titleTrusted) {
		this.$set({ titleTrusted });
		flush();
	}

	get text() {
		return this.$$.ctx[7];
	}

	set text(text) {
		this.$set({ text });
		flush();
	}

	get textTrusted() {
		return this.$$.ctx[8];
	}

	set textTrusted(textTrusted) {
		this.$set({ textTrusted });
		flush();
	}

	get styling() {
		return this.$$.ctx[31];
	}

	set styling(styling) {
		this.$set({ styling });
		flush();
	}

	get icons() {
		return this.$$.ctx[32];
	}

	set icons(icons) {
		this.$set({ icons });
		flush();
	}

	get mode() {
		return this.$$.ctx[9];
	}

	set mode(mode) {
		this.$set({ mode });
		flush();
	}

	get addClass() {
		return this.$$.ctx[10];
	}

	set addClass(addClass) {
		this.$set({ addClass });
		flush();
	}

	get cornerClass() {
		return this.$$.ctx[11];
	}

	set cornerClass(cornerClass) {
		this.$set({ cornerClass });
		flush();
	}

	get autoOpen() {
		return this.$$.ctx[33];
	}

	set autoOpen(autoOpen) {
		this.$set({ autoOpen });
		flush();
	}

	get width() {
		return this.$$.ctx[34];
	}

	set width(width) {
		this.$set({ width });
		flush();
	}

	get minHeight() {
		return this.$$.ctx[35];
	}

	set minHeight(minHeight) {
		this.$set({ minHeight });
		flush();
	}

	get icon() {
		return this.$$.ctx[0];
	}

	set icon(icon) {
		this.$set({ icon });
		flush();
	}

	get animation() {
		return this.$$.ctx[12];
	}

	set animation(animation) {
		this.$set({ animation });
		flush();
	}

	get animateSpeed() {
		return this.$$.ctx[13];
	}

	set animateSpeed(animateSpeed) {
		this.$set({ animateSpeed });
		flush();
	}

	get shadow() {
		return this.$$.ctx[14];
	}

	set shadow(shadow) {
		this.$set({ shadow });
		flush();
	}

	get hide() {
		return this.$$.ctx[36];
	}

	set hide(hide) {
		this.$set({ hide });
		flush();
	}

	get delay() {
		return this.$$.ctx[37];
	}

	set delay(delay) {
		this.$set({ delay });
		flush();
	}

	get mouseReset() {
		return this.$$.ctx[38];
	}

	set mouseReset(mouseReset) {
		this.$set({ mouseReset });
		flush();
	}

	get remove() {
		return this.$$.ctx[39];
	}

	set remove(remove) {
		this.$set({ remove });
		flush();
	}

	get destroy() {
		return this.$$.ctx[40];
	}

	set destroy(destroy) {
		this.$set({ destroy });
		flush();
	}

	get stack() {
		return this.$$.ctx[1];
	}

	set stack(stack) {
		this.$set({ stack });
		flush();
	}

	get modules() {
		return this.$$.ctx[2];
	}

	set modules(modules) {
		this.$set({ modules });
		flush();
	}

	get refs() {
		return this.$$.ctx[3];
	}

	get getState() {
		return this.$$.ctx[41];
	}

	get getStyle() {
		return this.$$.ctx[15];
	}

	get getIcon() {
		return this.$$.ctx[16];
	}

	get init() {
		return this.$$.ctx[42];
	}

	get open() {
		return this.$$.ctx[43];
	}

	set open(open) {
		this.$set({ open });
		flush();
	}

	get close() {
		return this.$$.ctx[44];
	}

	set close(close) {
		this.$set({ close });
		flush();
	}

	get animateIn() {
		return this.$$.ctx[45];
	}

	set animateIn(animateIn) {
		this.$set({ animateIn });
		flush();
	}

	get animateOut() {
		return this.$$.ctx[46];
	}

	set animateOut(animateOut) {
		this.$set({ animateOut });
		flush();
	}

	get cancelClose() {
		return this.$$.ctx[47];
	}

	get queueClose() {
		return this.$$.ctx[48];
	}

	get _preventTimerClose() {
		return this.$$.ctx[49];
	}

	get fire() {
		return this.$$.ctx[50];
	}

	get addModuleClass() {
		return this.$$.ctx[51];
	}

	get removeModuleClass() {
		return this.$$.ctx[52];
	}

	get hasModuleClass() {
		return this.$$.ctx[53];
	}

	get getModuleAccessors() {
		return this.$$.ctx[54];
	}

	get getModuleIsNoticeOpen() {
		return this.$$.ctx[55];
	}

	get setModuleIsNoticeOpen() {
		return this.$$.ctx[56];
	}

	get setAnimating() {
		return this.$$.ctx[57];
	}

	get getAnimatingClass() {
		return this.$$.ctx[58];
	}

	get setAnimatingClass() {
		return this.$$.ctx[59];
	}

	get _getMoveClass() {
		return this.$$.ctx[60];
	}

	get _setMoveClass() {
		return this.$$.ctx[61];
	}

	get _setMasking() {
		return this.$$.ctx[62];
	}
}

export default PNotifyCoreComponent;

export {
	defaultStack,
	defaults,
	moduleRegistry as modules,
	modulesPrependContainer,
	modulesAppendContainer,
	modulesPrependContent,
	modulesAppendContent,
	styleRegistry as styles,
	iconRegistry as icons
};
//# sourceMappingURL=PNotifyCoreComponent.js.map