<!--
 ====== PNotify ======

 http://sciactive.com/pnotify/

 Copyright 2009-2020 Hunter Perrin
 Copyright 2015 Google, Inc.

 Licensed under Apache License, Version 2.0.
  http://www.apache.org/licenses/LICENSE-2.0
-->

<svelte:options accessors={true} />

<script context="module">
  import Stack from './Stack.js';

  let posTimer;

  // These actions need to be done once the DOM is ready.
  function onDocumentLoaded () {
    defaultStack.context = document.body;
    // Reposition the notices when the window resizes.
    window.addEventListener('resize', () => {
      // This timer is used for queueing the position event so it doesn't run
      // repeatedly.
      if (posTimer) {
        clearTimeout(posTimer);
      }
      posTimer = setTimeout(() => {
        var event = new Event('pnotify:position');
        document.body.dispatchEvent(event);
        posTimer = null;
      }, 10);
    });
  }

  export const defaultStack = new Stack({
    dir1: 'down',
    dir2: 'left',
    firstpos1: 25,
    firstpos2: 25,
    spacing1: 36,
    spacing2: 36,
    push: 'bottom'
  });

  export const defaults = {
    // Type of the notice. 'notice', 'info', 'success', or 'error'.
    type: 'notice',
    // The notice's title. Can be a string, an element, or `false` for no title.
    title: false,
    // Whether to trust the title or escape its contents. (Not allow HTML.)
    titleTrusted: false,
    // The notice's text. Can be a string, an element, or `false` for no text.
    text: false,
    // Whether to trust the text or escape its contents. (Not allow HTML.)
    textTrusted: false,
    // What styling classes to use. (Can be 'brighttheme', 'material',
    // 'bootstrap3', 'bootstrap4', or a styling object.)
    styling: 'brighttheme',
    // What icons to use (Can be 'brighttheme', 'material', 'bootstrap3',
    // 'fontawesome4', 'fontawesome5', or an icon object.)
    icons: 'brighttheme',
    // Light or dark version of the theme, if supported by the styling. This
    // overrides the CSS media query when a preference is given. (Can be
    // 'no-preference', 'light', or 'dark'.)
    mode: 'no-preference',
    // Additional classes to be added to the notice. (For custom styling.)
    addClass: '',
    // Class to be added to the notice for corner styling.
    cornerClass: '',
    // Display the notice immediately when it is created.
    autoOpen: true,
    // Width of the notice.
    width: '360px',
    // Minimum height of the notice. It will expand to fit content.
    minHeight: '16px',
    // Set icon to true to use the default icon for the selected
    // style/type, false for no icon, or a string for your own icon class.
    icon: true,
    // The animation to use when displaying and hiding the notice. 'none'
    // and 'fade' are supported through CSS. Others are supported
    // through the Animate module and Animate.css.
    animation: 'fade',
    // Speed at which the notice animates in and out. 'slow', 'normal',
    // or 'fast'. Respectively, 400ms, 250ms, 100ms.
    animateSpeed: 'normal',
    // Display a drop shadow.
    shadow: true,
    // After a delay, remove the notice.
    hide: true,
    // Delay in milliseconds before the notice is removed.
    delay: 8000,
    // Reset the hide timer if the mouse moves over the notice.
    mouseReset: true,
    // Remove the notice's elements from the DOM after it is removed.
    remove: true,
    // Whether to remove the notice from the stack array (and therefore,
    // history) when it is closed.
    destroy: true,
    // The stack on which the notices will be placed. Also controls the
    // direction the notices stack.
    stack: defaultStack,
    // This is where options for modules should be defined.
    modules: {}
  };

  // This object holds all the PNotify modules. They are used to provide
  // additional functionality.
  const moduleRegistry = {};
  export { moduleRegistry as modules };

  // Modules can add themselves to these to be rendered in the template.
  export const modulesPrependContainer = [];
  export const modulesAppendContainer = [];
  export const modulesPrependContent = [];
  export const modulesAppendContent = [];

  const styleRegistry = {
    bootstrap3: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    },
    bootstrap4: {
      container: 'alert',
      notice: 'alert-warning',
      info: 'alert-info',
      success: 'alert-success',
      error: 'alert-danger'
    }
  };
  export { styleRegistry as styles };

  // icons are separate from the style, since bs4 doesn't come with any
  const iconRegistry = {
    bootstrap3: {
      notice: 'glyphicon glyphicon-exclamation-sign',
      info: 'glyphicon glyphicon-info-sign',
      success: 'glyphicon glyphicon-ok-sign',
      error: 'glyphicon glyphicon-warning-sign'
    },
    // User must have Font Awesome v4.0+
    fontawesome4: {
      notice: 'fa fa-exclamation-circle',
      info: 'fa fa-info-circle',
      success: 'fa fa-check-circle',
      error: 'fa fa-exclamation-triangle'
    },
    // User must have Font Awesome v5.0+
    fontawesome5: {
      notice: 'fas fa-exclamation-circle',
      info: 'fas fa-info-circle',
      success: 'fas fa-check-circle',
      error: 'fas fa-exclamation-triangle'
    }
  };
  export { iconRegistry as icons };

  // Run the deferred actions once the DOM is ready.
  if (window && document.body) {
    onDocumentLoaded();
  } else {
    document.addEventListener('DOMContentLoaded', onDocumentLoaded);
  }
</script>

<div bind:this={refs.elem}
    class="
      ui-pnotify
      {icon !== false ? 'ui-pnotify-with-icon' : ''}
      {getStyle('element')}
      ui-pnotify-mode-{mode}
      {addClass}
      {_animatingClass}
      {_moveClass}
      {animation === 'fade' ? 'ui-pnotify-fade-'+animateSpeed : ''}
      {stack && (stack.modal === true || (stack.modal === 'ish' && _timer === 'prevented')) ? 'ui-pnotify-modal' : ''}
      {_masking ? 'ui-pnotify-masking ui-pnotify-masking-' + _masking : ''}
      {_maskingIn ? 'ui-pnotify-masking-in' : ''}
      {_moduleClasses.elem.join(' ')}
    "
    aria-live="assertive"
    role="alertdialog"
    on:mouseenter={handleInteraction}
    on:mouseleave={handleLeaveInteraction}
    on:focusin={handleInteraction}
    on:focusout={handleLeaveInteraction}
    ui-pnotify
    on:mouseover
    on:mouseout
    on:mouseenter
    on:mouseleave
    on:mousemove
    on:mousedown
    on:mouseup
    on:click
    on:dblclick
    on:focus
    on:blur
    on:focusin
    on:focusout
    on:touchstart
    on:touchmove
    on:touchend
    on:touchcancel
    on:animationend
    on:transitionend>
  <div bind:this={refs.container}
      class="
        ui-pnotify-container
        {getStyle('container')}
        {getStyle(type)}
        {cornerClass}
        {shadow ? 'ui-pnotify-shadow' : ''}
        {_moduleClasses.container.join(' ')}
      "
      style="{_widthStyle} {_minHeightStyle}"
      role="alert">
    {#if self}
      {#each modulesPrependContainer as module (module.key)}
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
    {#if icon !== false}
      <div bind:this={refs.iconContainer} class="ui-pnotify-icon {getStyle('icon')}">
        <span class={icon === true ? getIcon(type) : icon}></span>
      </div>
    {/if}
    <div bind:this={refs.content} class="ui-pnotify-content {getStyle('content')}">
      {#if self}
        {#each modulesPrependContent as module (module.key)}
          <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
        {/each}
      {/if}
      {#if title !== false}
        <div bind:this={refs.titleContainer} class="ui-pnotify-title {getStyle('title')}">
          {#if !_titleElement}
            {#if titleTrusted}
              {@html title}
            {:else}
              <span class="ui-pnotify-pre-line">{title}</span>
            {/if}
          {/if}
        </div>
      {/if}
      {#if text !== false}
        <div bind:this={refs.textContainer} class="ui-pnotify-text {getStyle('text')}" role="alert">
          {#if !_textElement}
            {#if textTrusted}
              {@html text}
            {:else}
            <span class="ui-pnotify-pre-line">{text}</span>
            {/if}
          {/if}
        </div>
      {/if}
      {#if self}
        {#each modulesAppendContent as module (module.key)}
          <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
        {/each}
      {/if}
    </div>
    {#if self}
      {#each modulesAppendContainer as module (module.key)}
        <svelte:component this={module} on:init={event => saveAccessor(module.key, event.detail)} _notice={self} {...modules[module.key]} />
      {/each}
    {/if}
  </div>
</div>

<script>
  import { onMount, beforeUpdate, tick, createEventDispatcher } from 'svelte';

  let self;
  const dispatch = createEventDispatcher();

  export let type = defaults.type;
  export let title = defaults.title;
  export let titleTrusted = defaults.titleTrusted;
  export let text = defaults.text;
  export let textTrusted = defaults.textTrusted;
  export let styling = defaults.styling;
  export let icons = defaults.icons;
  export let mode = defaults.mode;
  export let addClass = defaults.addClass;
  export let cornerClass = defaults.cornerClass;
  export let autoOpen = defaults.autoOpen;
  export let width = defaults.width;
  export let minHeight = defaults.minHeight;
  export let icon = defaults.icon;
  export let animation = defaults.animation;
  export let animateSpeed = defaults.animateSpeed;
  export let shadow = defaults.shadow;
  export let hide = defaults.hide;
  export let delay = defaults.delay;
  export let mouseReset = defaults.mouseReset;
  export let remove = defaults.remove;
  export let destroy = defaults.destroy;
  export let stack = defaults.stack;
  export let modules = Object.assign({}, defaults.modules);

  export const refs = {
    elem: null,
    container: null,
    content: null,
    iconContainer: null,
    titleContainer: null,
    textContainer: null
  };

  // The state can be 'initializing', 'waiting', 'opening', 'open', 'closing',
  // or 'closed'.
  let _state = 'initializing';
  // Auto close timer.
  let _timer = null;
  // Animation timer.
  let _animTimer = null;
  // Stores what is currently being animated (in or out).
  let _animating = false;
  // Stores the class that adds entry/exit animation effects.
  let _animatingClass = '';
  // Stores the class that adds movement animation effects.
  let _moveClass = '';
  // Stores whether the notice was hidden by a timer.
  let _timerHide = false;
  // Stores the accessors of the modules.
  let _moduleAccessors = {};
  // Holds classes that modules add for the notice element or container element.
  let _moduleClasses = {
    elem: [],
    container: []
  };
  // Modules that change how the notice displays (causing the notice element to
  // not appear) can set this to true to make PNotify assume the notice has
  // opened.
  let _moduleIsNoticeOpen = false;
  // The masking control for the second notice in a modalish stack when the
  // first notice is hovered.
  let _masking = false;
  let _maskingIn = false;
  let _maskingTimer = null;

  // These hold the instances to the Svelte-loaded modules.
  // const _modulesPrependContainerInstances = [];
  // const _modulesAppendContainerInstances = [];

  // This keeps the beforeUpdate handler from going into a loop when we're
  // taming Font Awesome's magic.
  let _updatingIcon = false;
  // Save the old value of hide and icon, so we can do our magic.
  let _oldHide = hide;
  let _oldIcon = icon;

  // Grab styles from the styling object or use the styles provided.
  $: _styles = typeof styling === 'object' ? styling : styleRegistry[styling];
  // Grab the icons from the icons object or use provided icons
  $: _icons = typeof icons === 'object' ? icons : iconRegistry[icons];
  $: _widthStyle = typeof width === 'string' ? 'width: ' + width + ';' : '';
  $: _minHeightStyle = typeof minHeight === 'string' ? 'min-height: ' + minHeight + ';' : '';
  $: _titleElement = title instanceof HTMLElement;
  $: _textElement = text instanceof HTMLElement;

  export const getState = () => _state;
  export const getStyle = name => (_styles && name in _styles) ? _styles[name] : styling + '-' + name;
  export const getIcon = name => (_icons && name in _icons) ? _icons[name] : icons + '-icon-' + name;

  beforeUpdate(async () => {
    if (_updatingIcon) {
      return;
    }

    runModules('update');

    // Update the timed hiding.
    if (_state !== 'closed' && _state !== 'waiting' && hide !== _oldHide) {
      if (!hide) {
        cancelClose();
      } else if (!_oldHide) {
        queueClose();
      }
    }

    // Queue a position
    if (_state !== 'closed' && _state !== 'closing' && stack && !stack._collapsingModalState) {
      stack.queuePosition();
    }

    // Font Awesome 5 uses dark magic by replacing the icon element with an SVG.
    // In order to make it play nice with Svelte, we have to clear the element
    // and make it again.
    if (
      icon !== _oldIcon &&
      (
        (icon === true && icons === 'fontawesome5') ||
        (typeof icon === 'string' && icon.match(/(^| )fa[srlb]($| )/))
      )
    ) {
      const newIcon = icon;
      icon = false;
      _updatingIcon = true;
      await tick();
      icon = newIcon;
      _updatingIcon = false;
    }

    // Save old options.
    _oldHide = hide;
    _oldIcon = icon;
  });

  $: if (_titleElement && refs.titleContainer) {
    refs.titleContainer.appendChild(title);
  }

  $: if (_textElement && refs.textContainer) {
    refs.textContainer.appendChild(text);
  }

  function handleInteraction (e) {
    // Stop animation, reset the removal timer when the user interacts.
    if (mouseReset && _state === 'closing') {
      if (!_timerHide) {
        return;
      }
      cancelClose();
    }
    // Stop the close timer.
    if (hide && mouseReset) {
      cancelClose();
    }
  }

  function handleLeaveInteraction (e) {
    // Start the close timer.
    if (hide && mouseReset && _animating !== 'out') {
      queueClose();
    }
  }

  export async function init (notice) {
    // Init is passed the instance, since Svelte does not give access to it.
    self = notice;

    if (stack) {
      // Add the notice to the notice array.
      stack._addNotice(self);
    }

    // Wait for self to propagate to modules.
    await tick();

    runModules('init');

    // We're now initialized, but haven't been opened yet.
    _state = 'closed';

    // Display the notice.
    if (autoOpen) {
      open();
    }
  }

  // This runs an event on all the modules.
  function runModules (event) {
    if (event === 'init') {
      // Initializing a module should only be done if it has an init
      // function, which means it's not rendered in the template.
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        initModule(key, _moduleAccessors[key]);
      }
      for (let key in moduleRegistry) {
        if (!moduleRegistry.hasOwnProperty(key)) {
          continue;
        }
        if ('factory' in moduleRegistry[key]) {
          const moduleOptions = Object.assign({
            _notice: self
          }, modules[key]);
          _moduleAccessors[key] = moduleRegistry[key].factory(self, moduleOptions);
          initModule(key, _moduleAccessors[key]);
        }
      }
    } else {
      for (let key in _moduleAccessors) {
        if (!_moduleAccessors.hasOwnProperty(key)) {
          continue;
        }
        if (event === 'update') {
          if ('$set' in _moduleAccessors[key]) {
            const moduleOptions = Object.assign({
              _notice: self
            }, modules[key]);
            _moduleAccessors[key].$set(moduleOptions);
          }
        } else {
          if (event in _moduleAccessors[key]) {
            _moduleAccessors[key][event]();
          }
        }
      }
    }
  }

  function saveAccessor (key, accessor) {
    _moduleAccessors[key] = accessor;
  }

  // This passes module options to a module.
  function initModule (key, accessor) {
    if (!modules.hasOwnProperty(key)) {
      modules[key] = {};
    }
    if ('$set' in accessor) {
      const moduleOptions = Object.assign({
        _notice: self
      }, modules[key]);
      accessor.$set(moduleOptions);
    }
    if ('init' in accessor) {
      accessor.init();
    }
  }

  function insertIntoDOM () {
    // If the notice is not in the DOM, or in the wrong context, append it.
    if (
      refs.elem &&
      !refs.elem.parentNode ||
      (
        stack &&
        stack.context &&
        stack.context !== refs.elem.parentNode
      )
    ) {
      if (stack && (stack.context || document.body)) {
        if (!stack.context) {
          stack.context = document.body;
        }
        stack.context.appendChild(refs.elem);
      } else {
        throw new Error('No context to insert this notice into.');
      }
    }
  }

  function removeFromDOM () {
    refs.elem && refs.elem.parentNode.removeChild(refs.elem);
  }

  // Display the notice.
  export let open = immediate => {
    if (_state === 'opening') {
      return;
    }
    if (_state === 'open') {
      if (hide) {
        queueClose();
      }
      return;
    }

    if (stack && stack._shouldNoticeWait()) {
      _state = 'waiting';
      return;
    }

    _state = 'opening';
    _masking = false;
    // This makes the notice visibity: hidden; so its dimensions can be
    // determined.
    _animatingClass = 'ui-pnotify-initial-hidden';
    runModules('beforeOpen');

    const afterOpenCallback = () => {
      // Now set it to hide.
      if (hide) {
        queueClose();
      }

      _state = 'open';

      runModules('afterOpen');
    };

    if (stack) {
      // Notify the stack that a notice has opened.
      stack._handleNoticeOpened(self);
    }

    if (_moduleIsNoticeOpen) {
      afterOpenCallback();
      return;
    }

    insertIntoDOM();

    // Wait until the DOM is updated.
    window.requestAnimationFrame(() => {
      if (stack) {
        // Mark the stack so it won't animate the new notice.
        stack._animation = false;
        if (stack.push === 'top') {
          // Reset the position data so the notice is positioned as the first
          // notice.
          stack._resetPositionData();
        }
        // Now position the stack's the notices.
        stack._positionNotice(self);
        stack.queuePosition(0);
        // Reset animation.
        stack._animation = true;
      }

      animateIn(afterOpenCallback, immediate);
    });
  };

  // Remove the notice.
  export let close = (immediate, timerHide, waitAfterward) => {
    if (_state === 'closing' || _state === 'closed') {
      return;
    }

    const runDestroy = () => {
      runModules('beforeDestroy');
      if (stack) {
        stack._removeNotice(self);
      }
      self.$destroy();
      runModules('afterDestroy');
      runModules('$destroy');
    };

    if (_state === 'waiting') {
      _state = 'closed';
      // It's debatable whether the notice should be destroyed in this case, but
      // I'm going to go ahead and say yes.
      if (destroy && !waitAfterward) {
        runDestroy();
      }
      return;
    }

    _state = 'closing';
    _timerHide = !!timerHide; // Make sure it's a boolean.
    runModules('beforeClose');

    if (_timer && _timer !== 'prevented' && clearTimeout) {
      clearTimeout(_timer);
    }
    _timer = null;

    animateOut(() => {
      _timerHide = false;
      _state = waitAfterward ? 'waiting' : 'closed';
      runModules('afterClose');
      if (stack) {
        stack._handleNoticeClosed(self);
      }
      if (destroy && !waitAfterward) {
        // If we're supposed to destroy the notice, run the destroy module
        // events, remove from stack, and let Svelte handle DOM removal.
        runDestroy();
      } else if (remove && !waitAfterward) {
        // If we're supposed to remove the notice from the DOM, do it.
        removeFromDOM();
      }
    }, immediate);
  };

  // Animate the notice in.
  export let animateIn = async (callback, immediate) => {
    // Declare that the notice is animating in.
    _animating = 'in';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'in') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (visible) {
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade' && !immediate) {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // eslint-disable-next-line no-unused-expressions
      refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.
      _animatingClass = 'ui-pnotify-in ui-pnotify-fade-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = 'ui-pnotify-in';
      await tick();
      finished();
    }
  };

  // Animate the notice out.
  export let animateOut = async (callback, immediate) => {
    // Declare that the notice is animating out.
    _animating = 'out';
    const finished = event => {
      if (event && refs.elem && event.target !== refs.elem) {
        return;
      }
      refs.elem && refs.elem.removeEventListener('transitionend', finished);
      if (_animTimer) {
        clearTimeout(_animTimer);
      }
      if (_animating !== 'out') {
        return;
      }
      let visible = _moduleIsNoticeOpen;
      if (!visible && refs.elem) {
        const domRect = refs.elem.getBoundingClientRect();
        for (let prop in domRect) {
          if (domRect[prop] > 0) {
            visible = true;
            break;
          }
        }
      }
      if (!refs.elem || !refs.elem.style.opacity || refs.elem.style.opacity === '0' || !visible) {
        _animatingClass = '';
        if (callback) {
          callback.call();
        }
        // Declare that the notice has completed animating.
        _animating = false;
      } else {
        // In case this was called before the notice finished animating.
        _animTimer = setTimeout(finished, 40);
      }
    };

    if (animation === 'fade' && !immediate) {
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      _animatingClass = 'ui-pnotify-in';
      // Just in case the event doesn't fire, call it after 650 ms.
      _animTimer = setTimeout(finished, 650);
    } else {
      _animatingClass = '';
      await tick();
      finished();
    }
  };

  // Cancel any pending removal timer.
  export function cancelClose () {
    if (_timer && _timer !== 'prevented') {
      clearTimeout(_timer);
    }
    if (_animTimer) {
      clearTimeout(_animTimer);
    }
    if (_state === 'closing') {
      // If it's animating out, stop it.
      _state = 'open';
      _animating = false;
      _animatingClass = animation === 'fade' ? 'ui-pnotify-in ui-pnotify-fade-in' : 'ui-pnotify-in';
    }
  }

  // Queue a close timer.
  export function queueClose () {
    if (_timer === 'prevented') {
      return;
    }
    // Cancel any current close timer.
    cancelClose();
    _timer = setTimeout(() => close(false, true), (isNaN(delay) ? 0 : delay));
  }

  export function _preventTimerClose (prevent) {
    if (prevent) {
      cancelClose();
      _timer = 'prevented';
    } else if (_timer === 'prevented') {
      _timer = null;
      if (_state === 'open' && hide) {
        queueClose();
      }
    }
  }

  export function fire (name, detail) {
    dispatch(name, detail);
  }

  export function addModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        _moduleClasses[element].push(className);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function removeModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      const idx = _moduleClasses[element].indexOf(className);
      if (idx !== -1) {
        _moduleClasses[element].splice(idx, 1);
      }
    }
    _moduleClasses[element] = _moduleClasses[element];
  }

  export function hasModuleClass (element, ...classNames) {
    for (let i = 0; i < classNames.length; i++) {
      let className = classNames[i];
      if (_moduleClasses[element].indexOf(className) === -1) {
        return false;
      }
    }
    return true;
  }

  export function getModuleAccessors () {
    return _moduleAccessors;
  }

  export function getModuleIsNoticeOpen () {
    return _moduleIsNoticeOpen;
  }

  export function setModuleIsNoticeOpen (value) {
    return _moduleIsNoticeOpen = value;
  }

  export function setAnimating (value) {
    return _animating = value;
  }

  export function getAnimatingClass () {
    return _animatingClass;
  }

  export function setAnimatingClass (value) {
    return _animatingClass = value;
  }

  export function _getMoveClass () {
    return _moveClass;
  }

  export function _setMoveClass (value) {
    return _moveClass = value;
  }

  export function _setMasking (value, immediate) {
    if (_maskingTimer) {
      clearTimeout(_maskingTimer);
    }
    if (value) {
      insertIntoDOM();
      _masking = value;
      if (immediate) {
        _maskingIn = true;
      } else {
        window.requestAnimationFrame(() => {
          if (_masking) {
            _maskingIn = true;
          }
        });
      }
    } else if (immediate) {
      _masking = false;
      _maskingIn = false;
      if (remove && ['open', 'opening', 'closing'].indexOf(_state) === -1) {
        removeFromDOM();
      }
    } else {
      const finished = () => {
        refs.elem && refs.elem.removeEventListener('transitionend', finished);
        if (_maskingTimer) {
          clearTimeout(_maskingTimer);
        }
        if (!_maskingIn) {
          _masking = false;
          if (remove && ['open', 'opening', 'closing'].indexOf(_state) === -1) {
            removeFromDOM();
          }
        }
      };

      _maskingIn = false;
      refs.elem && refs.elem.addEventListener('transitionend', finished);
      // eslint-disable-next-line no-unused-expressions
      refs.elem && refs.elem.style.opacity; // This line is necessary for some reason. Some notices don't fade without it.
      // Just in case the event doesn't fire, call it after 650 ms.
      _maskingTimer = setTimeout(finished, 650);
    }
  }
</script>

<style>
  /* -- Notice */
  :global(body > .ui-pnotify) {
    /* Notices in the body context should be fixed to the viewport. */
    position: fixed;
    /* Ensures notices are above everything */
    z-index: 100040;
  }
  :global(body > .ui-pnotify.ui-pnotify-modal) {
    z-index: 100042;
  }
  :global(.ui-pnotify) {
    position: absolute;
    height: auto;
    z-index: 1;
    display: none;
    transition: opacity .1s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-modal) {
    z-index: 3;
  }
  :global(.ui-pnotify.ui-pnotify-in) {
    display: block;
    opacity: 1;
  }
  :global(.ui-pnotify.ui-pnotify-initial-hidden) {
    display: block;
    visibility: hidden;
  }
  :global(.ui-pnotify.ui-pnotify-move) {
    transition: left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow) {
    transition: opacity .4s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-slow.ui-pnotify.ui-pnotify-move) {
    transition: opacity .4s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal) {
    transition: opacity .25s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-normal.ui-pnotify.ui-pnotify-move) {
    transition: opacity .25s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast) {
    transition: opacity .1s linear;
    opacity: 0;
  }
  :global(.ui-pnotify.ui-pnotify-fade-fast.ui-pnotify.ui-pnotify-move) {
    transition: opacity .1s linear, left .4s ease, top .4s ease, right .4s ease, bottom .4s ease;
  }
  :global(.ui-pnotify.ui-pnotify-masking) {
    display: block;
    -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
    mask-image: linear-gradient(to bottom, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
  }
  :global(.ui-pnotify.ui-pnotify-masking-up) {
    -webkit-mask-image: linear-gradient(to top, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
    mask-image: linear-gradient(to top, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
  }
  :global(.ui-pnotify.ui-pnotify-masking-left) {
    -webkit-mask-image: linear-gradient(to left, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
    mask-image: linear-gradient(to left, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
  }
  :global(.ui-pnotify.ui-pnotify-masking-right) {
    -webkit-mask-image: linear-gradient(to right, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
    mask-image: linear-gradient(to right, rgba(0, 0, 0, .8), rgba(0, 0, 0, 0) 30px, rgba(0, 0, 0, 0));
  }
  :global(.ui-pnotify.ui-pnotify-fade-in, .ui-pnotify.ui-pnotify-masking-in) {
    opacity: 1;
  }
  :global(.ui-pnotify .ui-pnotify-shadow) {
    -webkit-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    -moz-box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
    box-shadow: 0px 6px 28px 0px rgba(0,0,0,0.1);
  }
  :global(.ui-pnotify-container) {
    background-position: 0 0;
    padding: .8em;
    height: 100%;
    margin: 0;
  }
  :global(.ui-pnotify-container:after) {
    content: " "; /* Older browser do not support empty content */
    visibility: hidden;
    display: block;
    height: 0;
    clear: both;
  }
  :global(.ui-pnotify-container.ui-pnotify-sharp) {
    -webkit-border-radius: 0;
    -moz-border-radius: 0;
    border-radius: 0;
  }
  :global(.ui-pnotify-title) {
    display: block;
    white-space: pre-line;
    margin-bottom: .4em;
    margin-top: 0;
  }
  :global(.ui-pnotify.ui-pnotify-with-icon .ui-pnotify-content) {
    margin-left: 24px;
  }
  :global([dir=rtl] .ui-pnotify.ui-pnotify-with-icon .ui-pnotify-content) {
    margin-right: 24px;
    margin-left: 0;
  }
  /* Bootstrap 4: make title text a tad smaller. */
  :global(.ui-pnotify .bootstrap4-title) {
    font-size: 1.2rem;
  }
  :global(.ui-pnotify-pre-line) {
    white-space: pre-line;
  }
  :global(.ui-pnotify-icon),
  :global(.ui-pnotify-icon span) {
    display: block;
    float: left;
  }
  :global([dir=rtl] .ui-pnotify-icon),
  :global([dir=rtl] .ui-pnotify-icon span) {
    float: right;
  }
  /* Bootstrap 3: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap3-icon > span) {
    position: relative;
    top: 2px;
  }
  /* Bootstrap 4: correct positioning of icon. */
  :global(.ui-pnotify .bootstrap4-icon > span) {
    position: relative;
    top: 4px;
  }
  /* Overlay */
  :global(.ui-pnotify-modal-overlay) {
    background-color: rgba(0, 0, 0, .6);
    top: 0;
    left: 0;
    position: absolute;
    height: 100%;
    width: 100%;
    z-index: 2;
    transition: opacity .25s linear;
    opacity: 0;
    padding: 0 1rem;
    display: flex;
    justify-content: center;
    align-items: flex-end;
  }
  :global(.ui-pnotify-modal-overlay-up) {
    align-items: flex-start;
  }
  :global(.ui-pnotify-modal-overlay-left) {
    justify-content: flex-start;
    align-items: center;
  }
  :global(.ui-pnotify-modal-overlay-right) {
    justify-content: flex-end;
    align-items: center;
  }
  :global(.ui-pnotify-modal-overlay.ui-pnotify-modal-overlay-in) {
    opacity: 1;
  }
  :global(.ui-pnotify-modal-overlay-closes:after) {
    content: "×";
    font-family: Arial;
    font-size: 3rem;
    color: #fff;
    text-shadow: 0 0 .4rem #FFF;
  }
  :global(body > .ui-pnotify-modal-overlay) {
    position: fixed;
    z-index: 100041;
  }
</style>
